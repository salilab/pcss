package ProteasePipeline;

use strict;

use FileHandle;

use DBI;
use POSIX qw(ceil floor);

sub new{
    my ($class, $parameterFile) = @_;
    my $self = {};
    bless $self, $class;

    $self->{Parameters} = {};
    $self->readParameterFile($parameterFile);

    return $self;
}


#Rule of cleavage site:  position is marked by 1-based position of P1 residues
#Implemented in input files generated by convertCaspasesToNormal.pl, convertAllGrbToNormal.pl

sub readCleavageSeqsFile{

    my ($self) = @_;

    my $cleavageSeqFileName = $self->getParam("cleavage_seq_file_name");
    $self->writeLog("Reading cleavage sequence file");

    my $cleavageSeqFh = FileHandle->new("<" . $cleavageSeqFileName) || die "could not open $cleavageSeqFileName\n";
    my $flagNames;
    my $outputFlags;
    my $substrateInfo;
    my $seqCount = 1;
    my $cleavageSequenceLength;

    while (<$cleavageSeqFh>){
	chomp;
	my $line = $_;
	if ($line =~ /^\#/){
	    #process columns to get information on flag names and whether to output them
	    my @cols = split('\|', $line);
	    
	    my ($modbaseSeqIdCol, $secondaryIdCol, $pOnePositionCol, $cleavageSequenceCol, @flags) = split('\|', $line);
	    #ignore all column names except flags
	    my $flagCounter = 1;
	    
	    foreach my $flagCol (@flags){
		my ($flagName, $flagOutput) = split('\s+', $flagCol);
		$flagNames->{$flagCounter} = $flagName;
		$outputFlags->{$flagName} = $flagOutput;
		$flagCounter++;
	    }
	    $self->{FlagNames} = $flagNames;
	    $self->{OutputFlags} = $outputFlags;
	}
	else {
	    
	    my ($modbaseSeqId, $uniprotAccession, $pOnePosition, $cleavageSequence, @flags) = split('\|', $line);

	    next if ($cleavageSequence =~ /\-/);  #only two that I've seen in caspases, causes havoc

	    #only need length from first cleavage seq, assume all the rest have the same length (!!)
	    if ($seqCount == 1){
		$cleavageSequenceLength = length($cleavageSequence);
		$self->{CleavageSequenceLength} = $cleavageSequenceLength;
		
	    }
	    $seqCount++;
	    
	    my $nonPrimeSideLength = $self->getParam("non_prime_side_length");  #if cleavage sequence goes from P4 to P2', this is 4
	    my $primeSideLength = $self->getParam("prime_side_length");         #if cleavage sequence goes from P4 to P2', this is 2

	    my $cleavageSeqStartPosition = $pOnePosition - ($nonPrimeSideLength - 1);  #keep 1-based with '-1'
	    my $cleavageSeqEndPosition = $pOnePosition + $primeSideLength;
	    
	    if ($cleavageSequenceLength != ($primeSideLength + $nonPrimeSideLength)){
		die "Error: Substrate $uniprotAccession; length of (prime side + non prime side = $primeSideLength + $nonPrimeSideLength is not equal to length of the rest of cleavage sequences ($cleavageSequenceLength)\n";
	    }  #clean up when fixing dies.  Also consider that all cleavage sequences may not be of the same length?
	    my $spliceAccession;
	    if ($uniprotAccession =~ /(\S+)(\-.*)/){
		$uniprotAccession = $1;
		$spliceAccession = $uniprotAccession . $2;
	    }


	    $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{cleavageSequence} = $cleavageSequence;
	    $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{cleavageSeqStartPosition} = $cleavageSeqStartPosition;
	    $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{pOnePosition} = $pOnePosition;
	    $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{uniprotAccession} = $uniprotAccession;
	    $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{spliceAccession} = $spliceAccession;

	    $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{cleavageSeqEndPosition} = $cleavageSeqEndPosition;

	    my $flagCounter = 1;

	    #flag values are dynamically named, but later in the code will depend on correct naming
	    foreach my $flagValue (@flags){
		my $flagName = $flagNames->{$flagCounter};
		$substrateInfo->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{$flagName} = $flagValue;
		$flagCounter++;
	    }
	}
    }
    my $uniqueModbaseSeqIdCount = scalar(keys %$substrateInfo);
    $self->writeLog("Done reading cleavage sequences.  Read $seqCount total cleavage sequences in sequences $uniqueModbaseSeqIdCount proteins.");
    $self->{TotalSequenceCount} = $seqCount;
    $self->createColumnInfo();  #this can only be done after the flags have been loaded.  Probably could make it cleaner but OK for now.
    $self->{SubstrateInfo} = $substrateInfo;
}


sub getSequenceLengths{

    my ($self) = @_;

    return 0 unless $self->runMethod("getSequenceLengths");

    my $dbh = $self->getSynonymDbh();

    my $newSeqSth = $dbh->prepare("select sequence from aasequences where seq_id = ?");
    my $oldSeqSth = $dbh->prepare("select sequence from aasequences_old where seq_id = ?");

    my $modbaseSeqIds;
    my $sequenceLengths;

    my $substrateInfo = $self->{SubstrateInfo};
    
    foreach my $modbaseSeqId (keys %$substrateInfo){

	$newSeqSth->execute($modbaseSeqId);
	my $sequenceLength = 0;
	while (my ($sequence) = $newSeqSth->fetchrow_array()){
	    $sequenceLength = length($sequence);
	}
	if ($sequenceLength == 0){
	    $oldSeqSth->execute($modbaseSeqId);
	    while (my ($sequence) = $oldSeqSth->fetchrow_array()){
		$sequenceLength = length($sequence);
	    }
	    if ($sequenceLength == 0){
		$self->writeLog("Could not find sequence for modbase sequence id $modbaseSeqId");
		next;
	    }
	}
	$substrateInfo->{$modbaseSeqId}->{sequenceLength} = $sequenceLength;
    }
}


sub getBestModels{

    my ($self) = @_;

    return 0 unless $self->runMethod("getBestModels");

    my $dbh = $self->getDbh();
    my $newRunOnly = $self->getParam("new_run_only");
    my $newRunName = $self->getParam("new_run_name");

    my $query = "select target_beg, target_end, maxseq_ident, evalue, model_score, run, model_id, align_id, zdope, no, tsvmod_method from newmodels where seq_id = ?";
    if ($newRunOnly eq "yes"){
	$query .= " and run = '$newRunName'";
    }

    my $sth = $dbh->prepare($query);

    my $substrateInfo = $self->{SubstrateInfo};

    my $sequenceCount = 0;

    my $writeAllModels;
    my $allModelsFh;
    if ($self->getParam("write_all_models") eq "yes"){
	$writeAllModels = 1;
	my $pipelineDir = $self->getParam("pipeline_directory");
	my $runName = $self->getParam("run_name");
	my $allModelsFile = "$pipelineDir/runs/$runName/pipelineResults/allModels_" . $runName . ".txt";
	$allModelsFh = FileHandle->new(">" . $allModelsFile) || die "could not open $allModelsFile\n";
	print $allModelsFh "Protein ID\tContains Cleavage Seq\tEnd Cut Off\tTarget Start\tTarget End\tCleavage Seq Start\tCleavage Seq End\tModel Score\tTemplate Sequence ID\tModel Coverage\tDataset\tSequence crc\tModel ID\tURL\n";
    }

    my $bestModelCriteria = $self->getParam("best_model_criteria");

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	my $sequenceLength = $substrateInfo->{$modbaseSeqId}->{sequenceLength};
	$sequenceCount++;
	$self->writeLog("GetBestModels:  got model for sequence number $sequenceCount") if ($sequenceCount % 1000 == 0);
	next if ($sequenceLength == 0);
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){

	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $cleavageSeqStartPosition = $seqInfo->{cleavageSeqStartPosition};
	    my $cleavageSeqEndPosition = $seqInfo->{cleavageSeqEndPosition};

	    my $uniprotAccession = $seqInfo->{uniprotAccession};

	    $sth->execute($modbaseSeqId);

	    my $resultInfo;

	    my $totalModelCount;
	    my $sequenceModelCount;

	    while (my ($modelTargetStart, $modelTargetEnd, $seqIdentity, $eValue, $modelScore, $run, $modelId, $alignId, $zDope, $nativeOverlap, $tsvmodMethod) = $sth->fetchrow_array()){
		
		$totalModelCount++;
		
		next if ($run =~ /ModWeb/);
		
		my $modelLength = $modelTargetEnd - $modelTargetStart;
		my $coverage = ($modelLength * 1.0) / ($sequenceLength * 1.0);
		my $roundedCoverage = sprintf("%.2f", $coverage);
		
		if ($modelTargetStart <= $cleavageSeqStartPosition && $modelTargetEnd >= $cleavageSeqEndPosition){
		    
		    if ($run eq "human" || $run eq "human_4-2007" || $run eq "snp-human2" || $run eq "snp-human3" 
			|| $run eq "snp-human4" || $run eq "trembl2004" || $run eq "human_2008"){ #only 'accepted' runs for now, expand later
			
			$sequenceModelCount++;
			$resultInfo->{$modelId}->{modelTargetStart} = $modelTargetStart;
			$resultInfo->{$modelId}->{modelTargetEnd} = $modelTargetEnd;
			$resultInfo->{$modelId}->{seqIdentity} = $seqIdentity;
			$resultInfo->{$modelId}->{modelScore} = $modelScore;
			
			$resultInfo->{$modelId}->{run} = $run;
			$resultInfo->{$modelId}->{alignId} = $alignId;
			$resultInfo->{$modelId}->{eValue} = $eValue;
			
			$resultInfo->{$modelId}->{zDope} = $zDope;
			$resultInfo->{$modelId}->{nativeOverlap} = $nativeOverlap;
			$resultInfo->{$modelId}->{tsvmodMethod} = $tsvmodMethod;

			$resultInfo->{$modelId}->{coverage} = $coverage;
		    }
		}

		#write to model info file
		$self->writeAllModelsLine($uniprotAccession, $modbaseSeqId, $modelId, $run, $modelTargetStart, $modelTargetEnd, $cleavageSeqStartPosition, 
				    $cleavageSeqEndPosition, $modelScore, $seqIdentity, $roundedCoverage, $allModelsFh) if $writeAllModels;
	    }
	    
	    #find best model according to specified criteria
	    my $bestModelId = $self->getBestModelByCriteria($resultInfo, $bestModelCriteria);
	    
	    #put all info for best model into $seqInfo
	    if ($bestModelId){
		foreach my $infoType (keys %{$resultInfo->{$bestModelId}}){
		    $seqInfo->{$infoType} = $resultInfo->{$bestModelId}->{$infoType};
		}
		$seqInfo->{bestModelId} = $bestModelId;
		
		my $alignmentId = $seqInfo->{alignId};
		my $run = $seqInfo->{run};

		my $fullAlignmentFileName = $self->getAlignmentFileName($modbaseSeqId, $alignmentId, $run);
		
		my $templatePdbIds = $self->getTemplatePdbIds($modbaseSeqId, $cleavageSeqId, $fullAlignmentFileName, $run);
		

		$seqInfo->{templatePdbIds} = $templatePdbIds;
		$seqInfo->{fullAlignmentFilePath} = $fullAlignmentFileName;
		$seqInfo->{sequenceModelCount} = $sequenceModelCount;
 	    }
	    $seqInfo->{totalModelCount} = $totalModelCount;

	}
    }
}

sub getBestModelByCriteria{

    my ($self, $resultInfo, $bestModelCriteria) = @_;   #assumes the best is always the one with the greatest score; true for native overlap, coverage, model score, not DOPE (if we add it)

    my $currentBestCriteria = 0.0;
    my $currentBestModelId;
    foreach my $modelId (keys %$resultInfo){
	my $currentCriteria = $resultInfo->{$modelId}->{$bestModelCriteria};
	if ($currentCriteria > $currentBestCriteria){
	    $currentBestModelId = $modelId;
	    $currentBestCriteria = $currentCriteria;
	}
    }
    return $currentBestModelId;
}


sub runDssp{
    my ($self) = @_;
  
    return 0 unless $self->runMethod("runDssp");
  
    my $pipelineDir = $self->getParam("pipeline_directory");
    my $dsspDir = $self->getParam("dssp_directory");   

    my $substrateInfo = $self->{SubstrateInfo};

    my $sequenceCount = 0;
    my $totalSequenceCount = $self->{TotalSequenceCount};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
    
	    $sequenceCount++;
	    $self->writeLog("Running DSSP for sequence number $sequenceCount (out of $totalSequenceCount") if ($sequenceCount % 1000 == 0);

	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};

	    #string for destination directory
  
	    my $run = $seqInfo->{run};
   
	    $modbaseSeqId =~ /^(\S\S\S)\S+/;
	    my  $seqTopDir = $1;
	    my $homeModelDir = "$dsspDir/$seqTopDir/$modbaseSeqId";

	    #create strings representing source and destination directories for the best model for this sequence
	    #source  eg   /park1/modbase/projects/genomes/human/data/f5f/f5fbd7d04fda19981c2dca8d803543e5MQQAETPQ/models
	    my $bestModelId = $seqInfo->{bestModelId};   
	    
	    next unless $bestModelId;
	    	    
	    my $modbaseModelDir = $self->getModelPath($run, $modbaseSeqId, $bestModelId);

	    my $modelZipFile = $modbaseModelDir . "/" . $bestModelId . ".pdb.gz";
	
	    if (-e $modelZipFile == 0){
		my $errorString = "Did not find model file $modelZipFile in expected directory";
		$self->writeError($modbaseSeqId, $cleavageSeqId, $bestModelId, "no_model_in_expected_directory", "runDssp", $errorString, 1);
		next;
	    }
    
	    #Check if DSSP has already been run on the best model for this sequence.  (If this script changes to select a different model than the one
	    #we are currently defining as the best one, will have to redo this check, because it is a check for the sequence, *not* the model)
	    if (-e "$homeModelDir/$bestModelId" . ".dssp"){
		next;
	    }

	    #make destination directory, copy model pdb, unzip
	
	    my $mkTopDirCmd = "mkdir -p $homeModelDir";
    	    system($mkTopDirCmd);

	    my $cpCmd = "cp $modelZipFile $homeModelDir";
	    my $cpOutput = `$cpCmd 2>&1`;

	    my $unzipCmd = "gunzip -f $homeModelDir/$bestModelId.pdb.gz";
	    my $unzipOutput = `$unzipCmd 2>&1`;

	    #run dssp
	    my $dsspOutputFile = "$homeModelDir/$bestModelId.dssp";
	    my $dsspCmd = "$pipelineDir/bin/dsspcmbi $homeModelDir/$bestModelId.pdb > $dsspOutputFile ";
	    my $dsspOutput = `$dsspCmd 2>&1`;
    
	    #remove pdb file
	    my $rmCmd = "rm $homeModelDir/$bestModelId.pdb";
    	    system ($rmCmd);
	}
    }
}


sub getTemplateLoopAlignment{

    my ($self) = @_;
    
    return 0 unless $self->runMethod("getTemplateLoopAlignment");
    
    my $substrateInfo = $self->{SubstrateInfo};
    my $sequenceCount = 0;
    my $totalSequenceCount = $self->{TotalSequenceCount};
    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    	    
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    
	    my $bestModelId = $seqInfo->{bestModelId};
	    if ($bestModelId){
		
		$sequenceCount++;
		$self->writeLog("Getting loop alignment for sequence number $sequenceCount (out of $totalSequenceCount") if ($sequenceCount % 1000 == 0);
		
		my $alignmentId = $seqInfo->{alignId};
		my $run = $seqInfo->{run};
		my $runInfo = $self->getRunInfo();
		my $runStyle = $runInfo->{$run}->{style};
		my $fullAlignmentFileName = $self->getAlignmentFileName($modbaseSeqId, $alignmentId, $run);
	
		#get info from alignment file
		my ($targetInfoLine, $targetSequence, $templateInfoLine, $templateSequence) = $self->parseAlignmentFile($fullAlignmentFileName, $run);
		
		#1-based position of cleavage sequence in the alignment file sequence string
		my ($targetModelCleavageSeqStart, $targetModelCleavageSeqEnd) = $self->getTargetModelCleavageSeqBoundaries($targetInfoLine, $targetSequence, $modbaseSeqId, 
															   $cleavageSeqId, $seqInfo, $fullAlignmentFileName, $runStyle);
		#get sequence of target (possibly including gaps) in the model alignment file
		my $templateCleavageSequence = substr($templateSequence, $targetModelCleavageSeqStart - 1, ($targetModelCleavageSeqEnd - $targetModelCleavageSeqStart + 1));

		#get corresponding sequence in template 
		my $targetModelCleavageSequence = substr($targetSequence, $targetModelCleavageSeqStart - 1, ($targetModelCleavageSeqEnd - $targetModelCleavageSeqStart + 1));
		
		#compare two sequences to see how similar they are
		my $similarityString = $self->makeSimilarityString($targetModelCleavageSequence, $templateCleavageSequence);

		$seqInfo->{templateCleavageSequence} = $templateCleavageSequence;
		$seqInfo->{similarityString} = $similarityString;
	    }
	}
    }
}


sub makeSimilarityString{
    my ($self, $targetCleavageSequence, $templateCleavageSequence) = @_;
    my @targetArray = split('', $targetCleavageSequence);
    my @templateArray = split('', $templateCleavageSequence);
    
    my $similarityString = "";
    for (my $i = 0; $i < scalar(@targetArray); $i++){
	my $targetRes = $targetArray[$i];
	my $templateRes = $templateArray[$i];

	if ($templateRes eq "-"){
	    $similarityString .= "-";
	}
	elsif ($targetRes eq "-"){
	    $similarityString .= "T";
	}
	elsif ($templateRes eq $targetRes){
	    $similarityString .= "I";
	}
	elsif ($self->areSimilar($templateRes, $targetRes)){
	    $similarityString .= "S";
	}
	else {
	    $similarityString .= "D";
	}
    }
    
    return $similarityString;
           
}


sub areSimilar{
    my ($self, $firstResidue, $secondResidue) = @_;
    my $groups = $self->{SimilarityGroups};
    
    my $areSimilar = 0;
    if ($groups->{$firstResidue}->{$secondResidue} == 1){
	$areSimilar = 1;
    }
    return $areSimilar;
}

sub parseDsspResults{

    my ($self) = @_;
    
    return 0 unless $self->runMethod("parseDsspResults");

    my $pipelineDir = $self->getParam("pipeline_directory");
    my $dsspDir = $self->getParam("dssp_directory");   #relative to pipeline dir, ok to keep static for now

    my $substrateInfo = $self->{SubstrateInfo};
    my $sequenceCount = 0;
    my $totalSequenceCount = $self->{TotalSequenceCount};
    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};

	foreach my $cleavageSeqId (keys %$cleavageSeqIds){

	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    $sequenceCount++;
	    $self->writeLog("Parsing DSSP results for sequence number $sequenceCount (out of $totalSequenceCount") if ($sequenceCount % 1000 == 0);
	    #get dssp file and open
	    $modbaseSeqId =~ /^(\S\S\S)\S+/;
	    my $seqTopDir = $1;
	    my $bestModelId = $seqInfo->{bestModelId};
	    next unless $bestModelId;
	    next if $self->isError($modbaseSeqId, $cleavageSeqId, "no_model_in_expected_directory", $bestModelId);
	    
	    my $noFile = 0;
	    my $dsspFile = "$dsspDir/$seqTopDir/$modbaseSeqId/$bestModelId.dssp";
	    my $dsspFh = FileHandle->new("<" . $dsspFile) || ($noFile = 1);
	    
	    if ($noFile == 1){
		print STDERR "could not open DSSP result file $dsspFile\n";   #this has happened occasionally and needs to be monitored.  Take out the die to do testing.
		die;
	    }
	    #takes the annotated cleavage sequence start position and offsets if, if necessary, in accordance with modbase model residue numbering
	    my ($cleavageSeqStartPosition, $cleavageSeqEndPosition) = $self->getModelCleavageRange($seqInfo);

	    my $cleavageSequence = $seqInfo->{cleavageSequence};

	    #move down past header info
	    while (<$dsspFh>){
		chomp;
		my $line = $_;
		    
		last if ($line =~ /\s+\#/);
	    }
	    
	    #read structure info
	    my $residueSolventAcc = $self->getResidueSolventAcc();
	    my $cleavageSiteSSInfo;
	    my $currentResiduePosition = 1; #starts at one no matter which style modpipe was used
	    my $baseOneCleavageStart;  #cleavage sites if pdb file were counted starting at one
	    my $baseOneCleavageEnd;
	    my $checkStructureString = "";
	    my @structureValueArray;
	    my @structureTypeArray;
	    my @accessibilityFractionArray;
	    my @accessibilityTypeArray;

	    while (<$dsspFh>){
		chomp;
		my $line = $_;
		
		last if ($line =~ /^\s+$/);
		
		# 1135 1145   G  S >  S+     0   0   56  .*
		
		#count #res  #code   #type             #acc
		if ($line =~ /\s+\d+\s+(\d+)\s+(\w)\s\s(.).{12}\s*\S+\s+(\d+).*/){
		    
		    my $residueNumber = $1;
		    my $residueOneLetter = $2;
		    my $structureType = $3;
		    my $accessibility = $4;
		    $currentResiduePosition++;
		    
		    $cleavageSiteSSInfo->{$currentResiduePosition} = $structureType;

		    #check if current residue is within the cleavage sequence boundaries
		    if ($residueNumber >= $cleavageSeqStartPosition && $residueNumber <= $cleavageSeqEndPosition){
			
			#quality control
			my $positionInCleavageSeq = $residueNumber - $cleavageSeqStartPosition + 1;
			$self->checkResidue($residueOneLetter, $positionInCleavageSeq, $cleavageSequence, $modbaseSeqId);
			$checkStructureString .= $structureType;
			
			#process secondary structure
			my ($mappedStructureType, $mappedStructureValue) = $self->getMappedStructureType($structureType);
		        push (@structureTypeArray, $mappedStructureType);
			push (@structureValueArray, $mappedStructureValue);


			#process solvent accessibility
			my ($percentAccessible, $accCall) = $self->getSolventExposureFraction($accessibility, $residueOneLetter, $residueSolventAcc);
			push (@accessibilityFractionArray, $percentAccessible);
			push (@accessibilityTypeArray, $accCall);
		    }
		
		    #prepare for counting loop length later
		    if ($residueNumber == $cleavageSeqStartPosition){
			$baseOneCleavageStart = $currentResiduePosition;
		    }
		    if ($residueNumber == $cleavageSeqEndPosition){
			$baseOneCleavageEnd = $currentResiduePosition;
		    }
		    
		}
		else {
		    $self->writeLog("dssp file line is $line; regex did not work");
		    die;
		}
	    }
	    if ($checkStructureString eq ""){  #for now assume that if we couldn't get a result for secondary structure, the same is true for solvent accessibility
		my $errorString = "Could not read DSSP secondary structure information from DSSP result file";
		$self->writeError($modbaseSeqId, $cleavageSeqId, $bestModelId, "no_dssp_structure_info", "parseDsspResults", $errorString, 1);
	    }
	    
	    #create strings from structure / accessibility values
	    my $structureTypeString = join('', @structureTypeArray);
	    my $structureValueString = join(',', @structureValueArray);
	    my $accessibilityTypeString = join('', @accessibilityTypeArray);
	    my $accessibilityFractionString = join(',', @accessibilityFractionArray);

	    #set structure / accessibilty values for this cleavage sequence
	    $seqInfo->{structureTypes} = $structureTypeString;
	    $seqInfo->{structureValues} = $structureValueString;
	    $seqInfo->{accessibilityTypes} = $accessibilityTypeString;
	    $seqInfo->{accessibilityFractions} = $accessibilityFractionString;

	    my $loopCount = $self->countCleavageSiteLoopLength($cleavageSiteSSInfo, $baseOneCleavageStart, $baseOneCleavageEnd);

	    $seqInfo->{"loopLength"} = $loopCount;
	}
    }
}


#has dependency on uniprot accessions being including
sub addLysateExpression{

    my ($self) = @_;
    
    return 0 unless $self->runMethod("addLysateExpression");
    
    my $affyMapFile = $self->getParam("affymetrix_map_file");
    my $lysateFile = $self->getParam("cell_lysate_file");   #if there is more than one will have to modify this

    my $affyMapFh = FileHandle->new("<" . $affyMapFile) || die "could not open affymetrix map file $affyMapFile for writing\n";

    my $uniprotToAffyMap;

    #make map of affymetrix -> uniprot
    
    my $uniprotAccessionCount;
    my $affyAccessionCount;
    while (<$affyMapFh>){
	chomp;
	my $line = $_;

	next if ($line =~ /^\#/);
	
	my @cols = split('\",\"', $line);    # \w \\ \w 

	my $affyId = $cols[0];
	$affyId =~ s/\"//g;
	
	my $uniprotAccessions = $cols[19];
	$uniprotAccessions =~ s/\"//g;

	my @uniprotAccessions = split('\s\/\/\/\s', $uniprotAccessions); #\w \\\ \w 
	$affyAccessionCount++;
	
	foreach my $uniprotAccession (@uniprotAccessions){
	    $uniprotAccessionCount++;
	    $uniprotToAffyMap->{$uniprotAccession}->{$affyId} = 1;
	}
    }
    
    $self->writeLog("addLysateExpression:  mapped $affyAccessionCount affy accessions to $uniprotAccessionCount non-unique uniprot accessions");

    my $lysateFh = FileHandle->new("<" . $lysateFile) || die "could not open lysate info file $lysateFile for writing\n";

    my $lysateMap;

    #read list of cell lines to use, map them to column numbers to use 
    my $cellLinesToUseParam = $self->getParam("cell_lines_to_use");  
    my @cellLinesToUse = split(',', $cellLinesToUseParam);
    my $cellLinesToUseHash;

    foreach my $cellLine (@cellLinesToUse){
	$cellLinesToUseHash->{$cellLine} = 1;
    }

    my $columnsToUse;   #map where key is column number and value is cell line name; only do for cell_lines_to_use
    my $columnList = <$lysateFh>;  #use first row to get names of cell lines;
    
    my @columns = split('\t', $columnList);
    my $columnCount = scalar(@columns);


    for (my $i = 2; $i < $columnCount; $i += 2){   #each column pair is cell line expression level (MAS5) followed by absent / present call. 
	my $nextCellLine = $columns[$i];   
	if ($cellLinesToUseHash->{$nextCellLine}){
	    $columnsToUse->{$i} = $nextCellLine;  
 	}
    }

    #note: in this file some cell lines have four entries; the first two are expression level numbers and the second two are A/P call
    #if we check output and see a number where expect A/P call, then will need to account for the four entries.
    #Jurkat / K562 / Malt4 all only have two columns.

    
    #read info from gene portal about which proteins are found in which cell lines

    my $lysateErrorCount = 0;

    my $proteinsInLysateCount;
    while (<$lysateFh>){
	
	chomp;
	my $line = $_;
	my @cols = split('\t', $line);
	my $affyId = $cols[0]; #affy id column
	$proteinsInLysateCount++;
	for (my $i = 2; $i < $columnCount; $i += 2){   #only take A/P call for now.  If needed will grab expression level later.
	    
	    my $nextCall = $cols[$i];

	    my $cellLine = $columnsToUse->{$i};
	    if ($cellLine){

		if ($nextCall =~ /\d/){
		    my $errorString = "Error: got value that was not 'A' or 'P' in expected absent / present call column in affy file (cell line: $cellLine error value: $nextCall column count $i affy id: $affyId)";
		    $self->writeError("N/A", "N/A", "N/A", "unexpected_lysate_call", "addLysateExpression", $errorString, 1);
		    $lysateErrorCount++;
		    exit(1) if ($lysateErrorCount > 1000);
		}
		$lysateMap->{$affyId}->{$cellLine} = $nextCall;
	    }
	}
    }

    $self->writeLog("addLysateExression:  Read in $proteinsInLysateCount proteins from lysate file");
    
    #For each of our substrates, find out if they are present or absent in lysates we care about
    my $substrateInfo = $self->{SubstrateInfo};
    #my $uniprotIdToAccessionMap = $self->{UniprotIdToAccessionMap};


    my $noAffyIdTranslationHash;
    my $foundAffyIdTranslationHash;

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    
	    my $uniprotAccession = $seqInfo->{uniprotAccession};
	    my $allCallsForAccession;  #map to keep track of all accessions and affy IDs.  
	    
	    my $affyIds = $uniprotToAffyMap->{$uniprotAccession};   #all affy IDs for accession
		
	    if ($affyIds){
		$foundAffyIdTranslationHash->{$uniprotAccession} = 1;
	    }
		
	    foreach my $affyId (keys %$affyIds){
		my $cellLineInfo = $lysateMap->{$affyId};    
		foreach my $cellLine (keys %$cellLineInfo){
		    my $call = $cellLineInfo->{$cellLine};
		    $allCallsForAccession->{$affyId}->{$cellLine} = $call;
		}
	    }
	    
	    #go through all affy ids for this uniprot id and add alls to $seqInfo
	    foreach my $affyId (keys %$allCallsForAccession){
		my $cellLines = $allCallsForAccession->{$affyId};
		foreach my $cellLine (keys %$cellLines){
		    my $call = $cellLines->{$cellLine};
		    $seqInfo->{cellLines}->{$cellLine}->{$affyId} = $call;
		}
	    }
	}
    }
    my $noAffyIdCount = scalar(keys %$noAffyIdTranslationHash);
    my $foundAffyIdCount = scalar(keys %$foundAffyIdTranslationHash);
    $self->writeLog("Done loading lysate info.  Found affymetrix translations for $foundAffyIdCount unique uniprot accessions.");   #should probably be more detailed
}


#has dependency on Uniprot accessions being included
sub addAntibodyAvailability{

    my ($self) = @_;

    return 0 unless $self->runMethod("addAntibodyAvailability");

    my $antibodyFile = $self->getParam("antibody_file");

    my $antibodyFh = FileHandle->new("<" . $antibodyFile) || die "could not open $antibodyFile for antibodies\n";

    my $antibodyInfo;
    my $substrateInfo = $self->{SubstrateInfo};

    while (<$antibodyFh>){

	chomp;
	my $line = $_;
	my ($number, $productName, $type, $proteinName, $uniprotAccessionString, $entrezId) = split ('\t', $line);

	my @finalUniprotAccessions;
	if ($uniprotAccessionString =~ /,/){
	    $uniprotAccessionString =~ s/"//g;   " # remove this quote for functional pipeline; added it there because it was messing up emacs colors
	    @finalUniprotAccessions = split(', ', $uniprotAccessionString);   #some of these entries are in "", separated by , -- this is the case when there are multiple entries
	}
	else {
	    push (@finalUniprotAccessions, $uniprotAccessionString);
	}
	foreach my $uniprotAccession (@finalUniprotAccessions){
	    

	    
	    my $secondaryAccessions = $self->{UniprotSecondaryAccessionMap}->{primaryToSecondary}->{$uniprotAccession};
	    $antibodyInfo->{$uniprotAccession}->{name} = $productName;
	    $antibodyInfo->{$uniprotAccession}->{number} = $number;

	    foreach my $secondaryAccession (keys %$secondaryAccessions){

		$antibodyInfo->{$secondaryAccession}->{name} = $productName;
		$antibodyInfo->{$secondaryAccession}->{number} = $number;
	    }
	}
    }

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};

	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};

	    my $uniprotAccession = $seqInfo->{uniprotAccession};
	    
	    #for this accession, search through all other accessions for the id to see if any have the antibody available

	    my $antibodyResult = $antibodyInfo->{$uniprotAccession};
	    
	    if ($antibodyResult){

		my $productName = $antibodyResult->{name};
		my $productNumber = $antibodyResult->{number};
				    
		$seqInfo->{availableAntibodyName} = $productName;
		$seqInfo->{availableAntibodyProductNumber} = $productNumber . " ($uniprotAccession)";
		last;
	    }
	}
    }
}


sub mapSecondaryAccessions{

    my ($self) = @_;
    return 0 unless $self->runMethod("mapSecondaryAccessions");
    
    my $accessionMapFile = $self->getParam("secondary_accession_map_file");

    my $accessionFh = FileHandle->new("<" . $accessionMapFile) || die "could not open accession map file $accessionMapFile\n";

    my $map;

    while (<$accessionFh>){
	chomp;
	my $line = $_;
	if ($line =~ /AC\s+(.*)/){
	    my $accessionList = $1;
	    $accessionList =~ s/;//g;
	    my @accessions = split('\s', $accessionList);
	    if (scalar(@accessions) > 1){
		my $primaryAccession = $accessions[0];
		for (my $i = 1; $i < scalar(@accessions); $i++){
		    my $secondaryAccession = $accessions[$i];
		    $map->{primaryToSecondary}->{$primaryAccession}->{$secondaryAccession} = 1;
		    $map->{secondaryToPrimary}->{$secondaryAccession} = {$primaryAccession};
		}
	    }
	}
    }
    $self->{UniprotSecondaryAccessionMap} = $map;

}


#This method is only used for mapping uniprot to ensembl or vice versa, now less useful since all input sequences are tagged with uniprot accessions
#Would be better to get dynamic mapping from Modbase instead of from files which may be outdated
#Method currently not being used since we don't really have a need for Ensembl accessions anymore
sub mapEnesmblAccessions{

    my ($self) = @_;

    return 0 unless $self->runMethod("mapEnsemblAccessions");

    my $initialAccessionType = $self->getParam("initial_accession_type");
    my $mappingFile;
    my $alternateAccessionName;  #either uniprot_accession or ensembl_id  -- this variable is only used for logging

    #get appropriate mapping file based on which accession type we started with
    if ($initialAccessionType eq "ensembl"){
	$mappingFile = $self->getParam("ensembl_to_uniprot_map_file");
	$alternateAccessionName = "uniprot_accession";
    }
    elsif ($initialAccessionType eq "uniprot"){
	$mappingFile = $self->getParam("uniprot_to_ensembl_map_file");
	$alternateAccessionName = "ensembl_id";
    }
    else {
	die "parameter initial_accesssion_type needs to be set to either ensembl or uniprot (and this parameter should be validated in the code initially, lazy-ass\n";
    }

    my $mappingFh = FileHandle->new("<" . $mappingFile) || die "could not open $mappingFile to get accession map\n";

    my $map;

    #read mapping fh
    while (<$mappingFh>){
	chomp;
	my $line = $_;
	my ($initialId, $alternateId) = split('\t', $line);
	$map->{$initialId} = $alternateId;
    }

    my ($noAccessionMapCount, $accessionWasMappedCount);
    
    my $substrateInfo = $self->{SubstrateInfo};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $uniprotAccession = $seqInfo->{uniprotAccession}; 
	    my $mappedId = $map->{$uniprotAccession};
	    if (!($mappedId)){
		$noAccessionMapCount++;
	    }
	    else {
		$accessionWasMappedCount++;
	    }
	    $seqInfo->{alternateAccession} =  $mappedId;
	}
    }
    
    $self->writeLog("Finished mapping accessions from $initialAccessionType to $alternateAccessionName.  Made $accessionWasMappedCount mappings and could not find translations for $noAccessionMapCount");

}



sub processNameAnnotation{
    my ($self) = @_;
    return 0 unless $self->runMethod("processNameAnnotation");
    
    my $substrateInfo = $self->{SubstrateInfo};
 
    my $descriptionsFile = $self->getParam("uniprot_descriptions_file");
    my $fh = FileHandle->new("<" . $descriptionsFile) || die "could not open $descriptionsFile to read uniprot descriptions\n";
    
    my $allDescriptions;
    while (<$fh>){
	chomp;
	my $line = $_;
	my ($accession, $description) = split ('\t', $line);
	$allDescriptions->{$accession} = $description;
    }

    my $foundDescriptionCount = 0;
    my $noDescriptionCount = 0;
    my $foundThroughSecondaryAccessionCount = 0;

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSiteIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSiteId (keys %$cleavageSiteIds){
	    
	    my $seqInfo = $cleavageSiteIds->{$cleavageSiteId};
	    my $uniprotAccession = $seqInfo->{uniprotAccession};

	    my $description = $allDescriptions->{$uniprotAccession};
	    unless ($description){
		my $primaryAccession = $self->{UniprotSecondaryAccessionMap}->{secondaryToPrimary}->{$uniprotAccession};
		my $description = $allDescriptions->{$primaryAccession};
		unless($description){
		    $noDescriptionCount++;
		}
		else {
		    $foundThroughSecondaryAccessionCount++;
		}
	    }
	    else {
		$foundDescriptionCount++;
	    }
	    $seqInfo->{description} = $description;
		
	}
    }
    $self->writeLog("Done getting name annotation.  Found descriptions for $foundDescriptionCount primary and $foundThroughSecondaryAccessionCount secondary accessions and could not find any for $noDescriptionCount uniprot accessions");

}









#took this out and read from file instead of database.  If that is acceptable then take this out entirely
sub processNameAnnotation_old{

    my ($self) = @_;
   
    return 0 unless $self->runMethod("processNameAnnotation");

    my $dbh = $self->getSynonymDbh();

    # will check if querying without the database_id improves the coverage on our results
#    my $sth = $dbh->prepare("select description from synonyms where seq_id = ? and database_id = ?");
    my $sth = $dbh->prepare("select description from synonyms where seq_id = ?");
    my $substrateInfo = $self->{SubstrateInfo};
 
    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSiteIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSiteId (keys %$cleavageSiteIds){
	    
	    my $seqInfo = $cleavageSiteIds->{$cleavageSiteId};
	    my $uniprotAccession = $seqInfo->{uniprotAccession};

#	    $sth->execute($modbaseSeqId, $uniprotAccession);
	    $sth->execute($modbaseSeqId);
	    while (my ($description) = $sth->fetchrow_array){
		$seqInfo->{description} = $description;
		last;  #just take the first result
	    }
	}
    }
}

sub applyHmm{

    my ($self) = @_;
    return unless $self->runMethod("applyHmm");

    #check if hmm score has been included with input set (this is the case for proteome-wide predictions)
    my $flagNames = $self->{OutputFlags};  #keys are flag names
    my $scoreIsInInput = 0;
    if ($flagNames->{"hmm_score_flag"}){
	$scoreIsInInput = 1;
    }
    
    #prepare HMM input files
    my $hmmModelFile = $self->getParam("hmm_model_file");
    my $hmmCmdFile = $self->getParam("hmm_cmd_file");
    my $pipelineDir = $self->getParam("pipeline_directory");
    my $runDir = $pipelineDir . "/bin/";
    my $hmmInputFileName = $runDir . "/hmmInputFile.fasta";
    my $hmmResultFileName = $runDir . "/hmmResultFile.txt";
    my $sequenceFh = FileHandle->new(">" . $hmmInputFileName) || die "could not open $hmmInputFileName for HMM writing\n";
				       
    #go through substrates, find all cleavage sequence, write to fasta file for HMM input
    my $substrateInfo = $self->{SubstrateInfo};
    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	
	    if ($scoreIsInInput > 0){
		$seqInfo->{hmmScore} = $seqInfo->{hmm_score_flag};  #transfer the results of the flag value to the final location in $seqInfo (this will be output in the appropriate column)
		$seqInfo->{hmmEValue} = $seqInfo->{hmm_evalue_flag};
	    }
	    else {  #write fasta input lines
		my $cleavageSequence = $seqInfo->{cleavageSequence};
		my $pOnePosition = $seqInfo->{pOnePosition};
		
		my $fastaLines = ">" . $modbaseSeqId . "|" . $pOnePosition . "|" . $cleavageSequence . "\n" . $cleavageSequence . "\n";  #create both header and sequence at once, write to hmm input file
		print $sequenceFh $fastaLines;
	    }
	}
    }

    #run hmmer, parse results
    if ($scoreIsInInput == 0){
	#run hmmer
	my $hmmCmd = $hmmCmdFile . " -E 50 $hmmModelFile $hmmInputFileName >  $hmmResultFileName";

	$self->writeLog("running hmm with command $hmmCmd");
	system ($hmmCmd);
	
	#get HMM results
	my $resultFh = FileHandle->new("<" . $hmmResultFileName) || die "could not open hmm result file $hmmResultFileName\n";
	
	while (<$resultFh>){
	    chomp;
	    my $line = $_;
	    
	    if ($line =~ /^Query\ssequence\:\s+(\S+)/){
		my $id = $1;
		my ($modbaseSeqId, $pOnePosition, $cleavageSequence) = split('\|', $id);
		
		for (my $i = 0; $i < 7; $i++){
		    $line = <$resultFh>; 
		}
		my @cols = split('\s+', $line);
		my $score = $cols[1];
		my $eValue = $cols[2];
		$self->{SubstrateInfo}->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{hmmScore} = $score;
		$self->{SubstrateInfo}->{$modbaseSeqId}->{cleavageSeqIds}->{$pOnePosition}->{hmmEValue} = $eValue;
		
	    }
	}
	my $runName = $self->getParam("run_name");
	my $mvCmd = "mv $hmmInputFileName $hmmResultFileName $pipelineDir/runs/$runName/";
	system($mvCmd);
    }
}


sub processPsipredResults{

    my ($self) =  @_;
    return unless $self->runMethod("processPsipredResults");
    
    my $substrateInfo = $self->{SubstrateInfo};

    my $psipredResultsDir = $self->getParam("psipred_results_dir");
    
    my $sequenceCount = 0;
    my $totalSequenceCount = $self->{TotalSequenceCount};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $cleavageSeqStartPosition = $seqInfo->{cleavageSeqStartPosition};
	    my $cleavageSeqEndPosition = $seqInfo->{cleavageSeqEndPosition};
	    my $cleavageSequence = $seqInfo->{cleavageSequence};
	    my @cleavageSeqArray = split('', $cleavageSequence);
	    my $length = length($cleavageSequence);

	    $sequenceCount++;
	    $self->writeLog("Getting Psipred result for sequence number $sequenceCount (out of $totalSequenceCount") if ($sequenceCount % 10000 == 0);

	    #Get psipred results file from modbase sequence id and input parameters
	    $modbaseSeqId =~ /^(\S\S)\S+/;
	    my $twoLetters = $1;
	    my $fullPsipredDir = $psipredResultsDir . "/" . $twoLetters;
	    my $fullPsipredFile = $fullPsipredDir . "/" . $modbaseSeqId . ".ss2";

	    my $noFile = 0;

	    my $psipredFh = FileHandle->new("<" . $fullPsipredFile) || ($noFile = 1);
	    if ($noFile == 1){
		$self->writeError($modbaseSeqId, $cleavageSeqId, 0, "no_psipred_result_file", "processPsipredResults", "Could not find Psipred Result File $fullPsipredFile", 1);
		next;
	    }
	    my $structureString = "";
	    my @firstScoreArray;
	    #scroll down to start of results
	    for (my $i = 0; $i < 2; $i++){
		<$psipredFh>;
	    }

	    while (<$psipredFh>){
		chomp;
		my $line = $_;
		if ($line =~ /^\s+(\S.*)/){
		    $line = $1;   #trim initial blank space form line for three digit residue numbers (four digit not an issue)
		}
		
		my ($residueNumber, $residueOneLetter, $structureCall, $firstScore, $secondScore, $thirdScore)  = split('\s+', $line);  
		

		if ($residueNumber == $cleavageSeqStartPosition){  #found cleavage sequence position, process the entire thing within the next for loop
		    for (my $i = 0; $i < $length; $i++){
			my $expectedCleavageSeqResidue = $cleavageSeqArray[$i];
			if ($expectedCleavageSeqResidue ne $residueOneLetter){
			    my $errorString =  "Error: psipred cleavage sequence letter $residueOneLetter position $residueNumber does not equal expected cleavage seq entry\n";
			    $errorString .= "$expectedCleavageSeqResidue in $cleavageSequence position $i in modbase sequence $modbaseSeqId\n";
			    $structureString = "psipred sequence error";  #fix this according to notes in comments at bottom of file
			    $self->writeError($modbaseSeqId, $cleavageSeqId, 0, "psipred_sequence_mismatch", "processPsipredResults", $errorString, 1);
			    
			}
			if ($structureCall eq "C"){
			    $structureString .= "L";
			}
			elsif ($structureCall eq "E"){
			    $structureString .= "B";
			}
			elsif ($structureCall eq "H"){
			    $structureString .= "A";
			}
			else {
			    
			    die "did not get expected psipred call for modbase seq id $modbaseSeqId position $residueNumber (should either be 'C', 'E', or 'H')\n";
			}

			push(@firstScoreArray, $firstScore);
			$line = <$psipredFh>;
			chomp $line;
			if ($line =~ /^\s+(\S.*)/){
			    $line = $1;   #trim initial blank space form line for three digit residue numbers (four digit not an issue)
			}
			($residueNumber, $residueOneLetter, $structureCall, $firstScore, $secondScore)  = split('\s+', $line); #read in next line
		    }
		    last; #we have finished the cleavage sequence.  Theoretically if the protein has more than one cleavage site we could keep going but will just process this sequence again instead
		}
	    }
	    if ($structureString eq ""){   #did not find expected cleavage seq start position in psipred result filexo
		$self->writeError($modbaseSeqId, $cleavageSeqId, 0, "no_psipred_cleavage_sequence", "processPsipredResults", "Found Psipred results file but did not find cleavage sequence start position $cleavageSeqStartPosition in file", 1); 

	    }
	    else {
		my $firstScoreString = join (',', @firstScoreArray);
		$seqInfo->{psipredString} = $structureString;
		$seqInfo->{psipredFirstScores} = $firstScoreString;
		#will probably be adding psipred score soon as well
	    }
	}
    }
}

    

sub processProfResults{

    my ($self) = @_;
    return unless $self->runMethod("processProfResults");

    my $substrateInfo = $self->{SubstrateInfo};

    my $profResultsDir = $self->getParam("prof_results_dir");
    
    my $sequenceCount = 0;
    my $totalSequenceCount = $self->{TotalSequenceCount};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $cleavageSeqStartPosition = $seqInfo->{cleavageSeqStartPosition};
	    my $cleavageSeqEndPosition = $seqInfo->{cleavageSeqEndPosition};
	    my $cleavageSequence = $seqInfo->{cleavageSequence};
	    my @cleavageSeqArray = split('', $cleavageSequence);
	    my $length = length($cleavageSequence);

	    $sequenceCount++;
	    $self->writeLog("Getting Prof result for sequence number $sequenceCount (out of $totalSequenceCount") if ($sequenceCount % 10000 == 0);
    
	    
	    #Get prof results file from modbase sequence id and input parameters
	    $modbaseSeqId =~ /^(\S\S)\S+/;
	    my $twoLetters = $1;
	    my $fullProfDir = $profResultsDir . "/" . $twoLetters;
	    my $fullProfFile = $fullProfDir . "/" . $modbaseSeqId . ".rdbProf";
    
	    my $noFile = 0;
	    
	    my $profFh = FileHandle->new("<" . $fullProfFile) || ($noFile = 1);
	    if ($noFile == 1){
		$self->writeError($modbaseSeqId, $cleavageSeqId, 0, "no_prof_result_file", "processProfResults", "Could not find Prof Result File $fullProfFile", 1);
		next;
	    }

	    my $accString = "";
	    my @relAccList;
	    my @reliabilityList;
	    my $columnMap;
	    while (<$profFh>){
		chomp;
		my $line = $_;
		next if ($line =~ /^#/);
		if ($line =~ /^No/){
		    my @cols = split('\t', $line);
		    my $counter = 1;
		    foreach my $col (@cols){
			$columnMap->{$col} = $counter;
			$counter++;
		    }
		}
		my @cols = split('\t', $line);
		my $baseOnePosition = $cols[0];
		my $oneLetterCode = $cols[1];
		my $relativeAcc = $cols[$columnMap->{"PREL"} - 1];
		my $reliability = $cols[$columnMap->{"RI_A"} - 1];
		my $threeStateExposure = $cols[$columnMap->{"Pbe"} - 1];  #subtract 1 because counter was 1-based;
		
		if ($baseOnePosition == $cleavageSeqStartPosition){
		    for (my $i = 0; $i < $length; $i++){
			my $expectedCleavageSeqResidue = $cleavageSeqArray[$i];
			if ($expectedCleavageSeqResidue ne $oneLetterCode){
			    my $errorString =  "Error: prof cleavage sequence letter $oneLetterCode position $baseOnePosition does not equal expected cleavage seq entry\n";
			    $errorString .= "$expectedCleavageSeqResidue in $cleavageSequence position $i in modbase sequence $modbaseSeqId\n";
			    $accString = "prof sequence error";  #fix this according to notes in comments at bottom of file
			    $self->writeError($modbaseSeqId, $cleavageSeqId, 0, "prof_sequence_mismatch", "processProfResults", $errorString, 1);
			}
	
			push(@relAccList, $relativeAcc);
			push(@reliabilityList, $reliability);
			$accString .= $threeStateExposure;
			$line = <$profFh>;
			chomp $line;
			@cols = split('\t', $line);
			$baseOnePosition = $cols[0];
			$oneLetterCode = $cols[1];
			$relativeAcc = $cols[$columnMap->{"PREL"} - 1];
			$reliability = $cols[$columnMap->{"RI_A"} - 1];
			$threeStateExposure = $cols[$columnMap->{"Pbie"} - 1];
		    }
		    last
		}
	    }
	    if ($accString eq ""){
		$seqInfo->{profAccString} = "prof no result error";
	    }
	    else {
		$seqInfo->{profAccString} = $accString;
		$seqInfo->{relativeAccScore} = join(',', @relAccList);
		$seqInfo->{profReliability} = join (',', @reliabilityList);
	    }
	}
    }
}


sub processDisopredResults {

    my ($self) = @_;
    return unless $self->runMethod("processDisopredResults");

    #Initially will only process $seqId.diso file.
    #If necessary will also process $seqId.horiz_d file which looks much more annoying to parse
    my $substrateInfo = $self->{SubstrateInfo};

    my $disopredResultsDir = $self->getParam("disopred_results_dir");
    
    my $sequenceCount = 0;
    my $totalSequenceCount = $self->{TotalSequenceCount};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $cleavageSeqStartPosition = $seqInfo->{cleavageSeqStartPosition};
	    my $cleavageSeqEndPosition = $seqInfo->{cleavageSeqEndPosition};
	    my $cleavageSequence = $seqInfo->{cleavageSequence};
	    my @cleavageSeqArray = split('', $cleavageSequence);
	    my $length = length($cleavageSequence);

	    $sequenceCount++;
	    $self->writeLog("Getting Disopred result for sequence number $sequenceCount (out of $totalSequenceCount") if ($sequenceCount % 10000 == 0);

	    #Get disopred results file from modbase sequence id and input parameters
	    $modbaseSeqId =~ /^(\S\S)\S+/;
	    my $twoLetters = $1;
	    my $fullDisopredDir = $disopredResultsDir . "/" . $twoLetters;
	    my $fullDisopredFile = $fullDisopredDir . "/" . $modbaseSeqId . ".diso";

	    my $noFile = 0;

	    my $disopredFh = FileHandle->new("<" . $fullDisopredFile) || ($noFile = 1);
	    if ($noFile == 1){
		$self->writeError($modbaseSeqId, $cleavageSeqId, 0, "no_disopred_result_file", "processDisopredResults", "Could not find Disopred Result File $fullDisopredFile", 1);
		next;
	    }
	    my $disorderString = "";
	    my @firstScoreList;
	    #scroll down to start of results
	    for (my $i = 0; $i < 5; $i++){
		<$disopredFh>;
	    }
#	    my ($blank, $residueNumber, $residueOneLetter, $disorderCall, $firstScore, $secondScore);
	    while (<$disopredFh>){
		chomp;
		my $line = $_;
		my ($blank, $residueNumber, $residueOneLetter, $disorderCall, $firstScore, $secondScore)  = split('\s+', $line);  #one-based residueNumber
		
		if ($residueNumber == $cleavageSeqStartPosition){  #found cleavage sequence position, process the entire thing within the next for loop
			
		    for (my $i = 0; $i < $length; $i++){
			my $expectedCleavageSeqResidue = $cleavageSeqArray[$i];
			if ($expectedCleavageSeqResidue ne $residueOneLetter){
			    my $errorString =  "Error: disopred cleavage sequence letter $residueOneLetter position $residueNumber does not equal expected cleavage seq entry\n";
			    $errorString .= "$expectedCleavageSeqResidue in $cleavageSequence position $i in modbase sequence $modbaseSeqId\n";
			    $disorderString = "disopred sequence error";  #fix this according to notes in comments at bottom of file
			    $self->writeError($modbaseSeqId, $cleavageSeqId, 0, "disopred_sequence_mismatch", "processDisopredResults", $errorString, 1);
			    
			}
			if ($disorderCall eq "*"){
			    $disorderString .= "D";
			}
			elsif ($disorderCall eq "."){
			    $disorderString .= "O";
			}
			else {
			    
			    die "did not get expected disopred call for modbase seq id $modbaseSeqId position $residueNumber (should either be '*' or '.')\n";
			}
			push (@firstScoreList, $firstScore);
			$line = <$disopredFh>;
			chomp $line;
			($blank, $residueNumber, $residueOneLetter, $disorderCall, $firstScore, $secondScore)  = split('\s+', $line); #read in next line
		    }
		    last; #we have finished the cleavage sequence.  Theoretically if the protein has more than one cleavage site we could keep going but will just process this sequence again instead
		}
	    }
	    if ($disorderString eq ""){   #did not find expected cleavage seq start position in disopred result file
		#die "Error: did not find expected cleavage seq start position in disopred result file for sequence $modbaseSeqId\n";
		$seqInfo->{disopredString} = "disopred no result error";
	    }
	    else {
		$seqInfo->{disopredString} = $disorderString;
		my $firstScoreString = join(',', @firstScoreList);
		$seqInfo->{disopredFirstScores} = $firstScoreString;
		#will probably be adding disopred score soon as well
	    }
	}
    }
}


sub processDomainAnnotation{

    my ($self) = @_;
    return unless $self->runMethod("processDomainAnnotation");
}


sub processCathAnnotation{

    my ($self) = @_;
    return unless $self->runMethod("processCathAnnotation");
}


sub findSharedCleavageSites{
    my ($self) = @_;
    return unless $self->runMethod("findSharedCleavageSites");

    my $otherProteaseFile = $self->getParam("other_cleavage_site_file");   #keep this generic so can process GrB for Caspase and vice versa

    my $otherProteaseFh = FileHandle->new("<" . $otherProteaseFile) || die "could not open other cleavage site file $otherProteaseFile\n";

    my $otherProteaseInfo;

    while (<$otherProteaseFh>){
	chomp;
	my $line = $_;
	
	next if ($line =~ /^\#/);
	
	my @cols = split('\|', $line);
	my $modbaseSeqId = $cols[0];
	my $accession = $cols[1];
	my $pOnePosition = $cols[2];
	my $cleavageSequence = $cols[3];
	$otherProteaseInfo->{$accession}->{$pOnePosition} = 1;
    }

    my $substrateInfo = $self->{SubstrateInfo};
 
    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};
	
	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $accession = $seqInfo->{uniprotAccession};
	    my $otherProteaseShared = $otherProteaseInfo->{$accession};
	    if ($otherProteaseShared){
		my $sharedString = "";
		if ($otherProteaseInfo->{$accession}->{$cleavageSeqId}){
		    $sharedString .= "protease_shared_site";
		}
		else {
		    $sharedString .= "protease_shared_substrate_different_site";
		}
		print STDERR "found shared string accession $accession:  $sharedString\n";
		$seqInfo->{sharedProteaseInfo} = $sharedString;
	    }
	}
    }
}


sub finalize {

    my ($self) = @_;

    $self->writeAllErrors();

    my $logFh = $self->{Log};
    $logFh->close();

    my $logFileName = $self->{LogFileName};
    my $pipelineDir = $self->getParam("pipeline_directory");
    my $runName = $self->getParam("run_name");
    my $logDestination = "$pipelineDir/runs/$runName";

    my $mvLogCmd = "mv $logFileName $logDestination";
    system($mvLogCmd);

    my $parameterFileName = $self->{ParameterFileName};
    my $cpParamCmd = "cp $parameterFileName $logDestination";
    system ($cpParamCmd);

}


sub processGoAnnotation{

    my ($self) = @_;
    
    return 0 unless $self->runMethod("processGoAnnotation");

    my $substrateInfo = $self->{SubstrateInfo};

    my $goAnnotation;
    my $goAnnotationFileName = $self->getParam("go_annotation_file_name");

    my $goFh = FileHandle->new("<" . $goAnnotationFileName) || die "could not open $goAnnotationFileName\n";

    while (<$goFh>){
	chomp;
	my $line = $_;
	my ($proteinId, $goId, $goEvidenceCode, $goDescription) = split('\t', $line);
	
	$goAnnotation->{$proteinId}->{$goId} = "($goEvidenceCode): " . $goDescription;

    }

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSiteIds = $substrateInfo->{$modbaseSeqId}->{cleavageSiteIds};
	
	foreach my $cleavageSiteId (keys %$cleavageSiteIds){
	    
	    my $seqInfo = $cleavageSiteIds->{$cleavageSiteId};
	    
	    my $goProteinId = $seqInfo->{go_protein_id};    #flag name
	    
	    my $goIds = $goAnnotation->{$goProteinId};
	    
	    my $goIdString = "";
	    my $goDescriptionString = "";
	    
	    foreach my $goId (keys %$goIds){
		my $goDescription = $goIds->{$goId};
		$goIdString .= "$goId, ";
		$goDescriptionString .= "$goDescription, ";
	    }
	    $seqInfo->{goIdString} = $goIdString;
	    $seqInfo->{goDescriptionString} = $goDescriptionString;
	}
    }
}

sub writeIntermediateResults{
    my ($self) = @_;
    return 0 unless $self->runMethod("writeIntermediateResults");

    my $pipelineDir = $self->getParam("pipeline_directory");
    my $runName = $self->getParam("run_name");

    my $substrateTableFile = "$pipelineDir/runs/$runName/pipelineResults/pipelineIntermediateTable_" . $runName . ".txt";

    my $substrateTableFh = FileHandle->new(">" . $substrateTableFile) || die "could not open $substrateTableFile for writing\n";
    
    print $substrateTableFh "sequence_id\tcleavage_site_id\tmodel_id\talign_id\trun_name\t";
    print $substrateTableFh "model_target_start\tmodel_target_end\t";
    print $substrateTableFh "seq_identity\tmodel_score\te_value\t";
    print $substrateTableFh "models_in_range\ttotal_models\t";
    print $substrateTableFh "cleavage_seq_start\tcleavage_seq_end\tcleavage_seq\tcoverage\tprotein_id\tloop_length\t";


    my $cleavageSeqLength = $self->{CleavageSequenceLength};

    for (my $i = 1; $i <= $cleavageSeqLength; $i++){
	print $substrateTableFh "structure_P" . $i . "\t";
    }
    
    for (my $i = 1; $i <= $cleavageSeqLength; $i++){
	print $substrateTableFh "accessibility_P" . $i . "\t";
    }
    
    my $flagNames = $self->{FlagNames};
    foreach my $flagNumber (sort keys %$flagNames){
	my $flagName = $flagNames->{$flagNumber};
	print $substrateTableFh $flagName . "\t";
    }

    print $substrateTableFh "\n";

    my $substrateInfo = $self->{SubstrateInfo};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};

	foreach my $cleavageSeqId (keys %$cleavageSeqIds){

	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};

	    #best model info
	    my $bestModelId = $seqInfo->{bestModelId};
	    next unless $bestModelId;
	    
	    my $alignId = $seqInfo->{alignId};
	    my $run = $seqInfo->{run};
	    my $uniprotAccession = $seqInfo->{uniprotAccession};
	    my $coverage = $seqInfo->{coverage};
	    
	    #model range
	    my $modelTargetStart = $seqInfo->{modelTargetStart};
	    my $modelTargetEnd = $seqInfo->{modelTargetEnd};
	    
	    #model scores
	    my $seqIdentity = $seqInfo->{seqIdentity};
	    my $modelScore = $seqInfo->{modelScore};
	    my $eValue = $seqInfo->{eValue};
	    
	    #total number of models
	    my $sequenceModelCount = $seqInfo->{sequenceModelCount};
	    my $totalModelCount = $seqInfo->{totalModelCount};
	    
	    #cleavage seq info
	    my $cleavageSeqStartPosition = $seqInfo->{cleavageSeqStartPosition};
	    my $cleavageSeqEndPosition =$seqInfo->{cleavageSeqEndPosition};
	    my $cleavageSeq = $seqInfo->{cleavageSequence};
	    
	    #loop length
	    my $loopLength = $seqInfo->{loopLength};

	    print $substrateTableFh "$modbaseSeqId\t$cleavageSeqId\t$bestModelId\t$alignId\t$run\t";
	    print $substrateTableFh "$modelTargetStart\t$modelTargetEnd\t";
	    print $substrateTableFh "$seqIdentity\t$modelScore\t$eValue\t";
	    print $substrateTableFh "$sequenceModelCount\t$totalModelCount\t";
	    print $substrateTableFh "$cleavageSeqStartPosition\t$cleavageSeqEndPosition\t$cleavageSeq\t";
	    print $substrateTableFh "$coverage\t$uniprotAccession\t$loopLength\t"; 

	    #cleavage seq structure info
	    for (my $i = 1; $i <= $cleavageSeqLength; $i++){
		my $keyName = "structureType_" . $i;
		my $structureType = $seqInfo->{$keyName};
		print $substrateTableFh $structureType . "\t";
	    }
	    for (my $i = 1; $i <= $cleavageSeqLength; $i++){
		my $keyName = "accessibility_" . $i;
		my $accessibility = $seqInfo->{$keyName};
		print $substrateTableFh $accessibility . "\t";
	    }
	    #flags
	    foreach my $flagNumber (sort keys %$flagNames){
		my $flagName = $flagNames->{$flagNumber};
		my $flagValue = $seqInfo->{$flagName};
		print $substrateTableFh $flagValue . "\t";
	    }
	    print $substrateTableFh "\n";
	}
    }
}


sub writeUserResults{

    my ($self) = @_;

    return unless $self->runMethod("writeUserResults");
    
    my $pipelineDir = $self->getParam("pipeline_directory");
    my $runName = $self->getParam("run_name");
    
    my $resultsFileName = "$pipelineDir/runs/$runName/pipelineResults/pipelineUserTable_" . $runName . ".txt";
    my $resultsFh = FileHandle->new(">" . $resultsFileName) || die "could not open $resultsFileName for writing\n";
    
    my $columnHeaderString = $self->makeColumnHeaderString();
    print $resultsFh $columnHeaderString . "\n";

    my $cleavageSeqLength = $self->{CleavageSequenceLength};
    my $residueSolventAcc = $self->getResidueSolventAcc();

    my $substrateInfo = $self->{SubstrateInfo};

    foreach my $modbaseSeqId (keys %$substrateInfo){
	my $cleavageSeqIds = $substrateInfo->{$modbaseSeqId}->{cleavageSeqIds};

	foreach my $cleavageSeqId (keys %$cleavageSeqIds){
	    
	    my $seqInfo = $cleavageSeqIds->{$cleavageSeqId};
	    my $bestModelId = $seqInfo->{bestModelId};
	    
	    my $outputInfo;

	    #general sequence information    
	    my @attributes = ("uniprotAccession", "alternateAccession", "spliceAccession", "totalModelCount", "sequenceModelCount", "run",  "modelTargetStart", "modelTargetEnd", "cleavageSeqStartPosition", "cleavageSeqEndPosition", "cleavageSequence",  "modelScore", "seqIdentity", "coverage", "loopLength", "sharedProteaseInfo", "description", "availableAntibodyName", "availableAntibodyProductNumber", "domainBoundaries", "domainBoundaryValue", "goIdString", "goDescriptionString", "disopredString", "disopredFirstScores", "profAccString", "relativeAccScore", "profReliability", "psipredString", "psipredFirstScores", "hmmScore", "hmmEValue", "fullAlignmentFilePath");
	    
	    foreach my $attribute (@attributes){
		my $value = $seqInfo->{$attribute};
		$outputInfo = $self->addOutputValue($outputInfo, $value, $attribute);
	    }

	    my $url = "http://salilab.org/modbase/search?modelID=" . $bestModelId . "&displaymode=moddetail";
	    
	    $outputInfo = $self->addOutputValue($outputInfo, $modbaseSeqId, "sequenceId");
	    $outputInfo = $self->addOutputValue($outputInfo, $bestModelId, "modelId");
	    $outputInfo = $self->addOutputValue($outputInfo, $cleavageSeqId, "pOnePosition");
	    $outputInfo = $self->addOutputValue($outputInfo, $url, "url");

	    
	    if ($bestModelId){
		
		my @structureAttributes = ("zDope", "nativeOverlap", "tsvmodMethod", "templatePdbIds", "similarityString", "templateCleavageSequence", "structureTypes", "accessibilityTypes", "structureValues", "accessibilityFractions");
		
		foreach my $structureAttribute (@structureAttributes){
		    my $value = $seqInfo->{$structureAttribute};
		    $outputInfo = $self->addOutputValue($outputInfo, $value, $structureAttribute);
		}
	    }

	    #cell lines
	    if ($self->getParam("addLysateExpression") eq "yes"){
		my $cellLinesUsed = $self->getParam("cell_lines_to_use");
		my @cellLineNames = split(',', $cellLinesUsed);

		my $cellLineInfo = $seqInfo->{cellLines};
		foreach my $cellLineName (@cellLineNames){   #the order will be correct because both the column names and the values were determined by the cell_lines_to_use param
		    my $callString = "";
		    my $affyIdString = "";
		    my $pCount = 0;
		    my $affyIds = $cellLineInfo->{$cellLineName};
		    foreach my $affyId(sort ({$affyIds->{$b} cmp $affyIds->{$a}} keys %$affyIds)){
			my $call = $affyIds->{$affyId};
			$callString .= $call . " ";
			$affyIdString .= $affyId . " ";
			if ($call eq 'P'){
			    $pCount++;
			}
		    }
		    my $finalString = "($pCount) . " . $callString . ": " . $affyIdString;
		    $outputInfo = $self->addOutputValue($outputInfo, $finalString, $cellLineName); 
		}
	    }
     
       	    #flags
	    my $flagNames = $self->{FlagNames};
	    my $outputFlags = $self->{OutputFlags};
	    foreach my $flagNumber (sort keys %$flagNames){
		my $flagName = $flagNames->{$flagNumber};
		if ($outputFlags->{$flagName} eq "yes"){

		    my $flagValue = $seqInfo->{$flagName};
		    $outputInfo = $self->addOutputValue($outputInfo, $flagValue, $flagName);
		}
	    }

	    my $outputLine = $self->makeOutputLine($outputInfo);
	    print $resultsFh $outputLine . "\n";
	}
    }
}


#################
#Helper Methods

#Read alignment file and return pir lines for both target and template, along with sequence as a string (including gaps)
sub parseAlignmentFile{

    my ($self, $fullAlignmentFileName, $runName) = @_;

    
    my $runInfo = $self->getRunInfo();
    my $runStyle = $runInfo->{$runName}->{style};
    
    my $alignmentFh = FileHandle->new("<" . $fullAlignmentFileName) || die "could not open $fullAlignmentFileName\n";
    
    
    #read in first protein
    my $blank = <$alignmentFh>;
    my $firstHeaderLine = <$alignmentFh>;
    my $firstInfoLine = <$alignmentFh>;
    my $firstSequence = "";

    #read in protein sequence
    while (<$alignmentFh>){ 
	my $line = $_;
	chomp $line;
	$firstSequence .= $line;
	if ($line =~ /\*/){
	    $firstSequence =~ /(.*)\*$/;  #trim trailing * from sequence we have already built
	    $firstSequence = $1;
	    last;
	}	
    }

    #read in second protein info
    my $blank = <$alignmentFh>;
    my $secondHeaderLine = <$alignmentFh>;
    my $secondInfoLine = <$alignmentFh>;
    my $secondSequence = "";

    #read in protein sequence
    while (<$alignmentFh>){
	my $line = $_;
	chomp $line;
	$secondSequence .= $line;
	if ($line =~ /\*/){
	    $secondSequence =~ /(.*)\*$/;  #trim trailing *
	    $secondSequence = $1;
	    last;
	}
    }

    my ($templateInfoLine, $targetInfoLine, $templateSequence, $targetSequence);
    
    if ($runStyle eq "old"){
	$templateInfoLine =  $firstInfoLine;
	$templateSequence = $firstSequence;

	$targetInfoLine =  $secondInfoLine;
	$targetSequence = $secondSequence;
    }
    elsif ($runStyle eq "new"){
	$targetInfoLine =  $firstInfoLine;
	$targetSequence = $firstSequence;

	$templateInfoLine =  $secondInfoLine;
	$templateSequence = $secondSequence;
    }
    else {
	die "did not get expected run style 'old' or 'new' for run $runName\n";
    }


    return ($targetInfoLine, $targetSequence, $templateInfoLine, $templateSequence);


}

#Returns the position of the cleavage sequence in the string representing the target in the model file
#Takes into account position of first modeled residue as well as gaps 
sub getTargetModelCleavageSeqBoundaries{ 
    my ($self, $targetInfoLine, $targetSequence, $modbaseSeqId, $cleavageSeqId, $seqInfo, $alignmentFileName, $runStyle) = @_;
    
    my ($targetModelCleavageSeqStart, $targetModelCleavageSeqEnd);
    my $targetModelStart;
    #get start of model coverage from alignment file
    my @cols = split('\:', $targetInfoLine);

    if ($runStyle eq "new"){
	$targetModelStart = $cols[2];

	#trim spaces 
	$targetModelStart =~ s/\s+//g;
    }
    else {
	my $positionCol = $cols[6];
	if ($positionCol =~ /\S+\s(\d+)\-/){
	    $targetModelStart = $1;
	}
	else {
	    die "Did not get expected format of model start for modbase seq $modbaseSeqId\n";
	}
    }
    

    #get annotated cleavage seq boundaries
    my $cleavageSeqStart = $seqInfo->{cleavageSeqStartPosition};
    my $cleavageSeqEnd = $seqInfo->{cleavageSeqEndPosition};

    #initial 1-based values of target model cleavage seq position
    $targetModelCleavageSeqStart = $cleavageSeqStart - $targetModelStart + 1;
    $targetModelCleavageSeqEnd = $cleavageSeqEnd - $targetModelStart + 1;

    my @seqArray = split('', $targetSequence);

    my $foundCleavageStart = 0;
    #go through sequence looking for gaps
    for (my $i = 0; $i < scalar(@seqArray); $i++){ 
	
	my $nextResidue = $seqArray[$i];
	if ($nextResidue eq "-"){
	    $targetModelCleavageSeqStart++ unless $foundCleavageStart;  #don't increment if we have already found the start in the seqArray
	    $targetModelCleavageSeqEnd++;
	}
	if (($i + 1) == $targetModelCleavageSeqStart){  #found start, keep looking for end ($targetModelCleavageSeqStart is still 1-based)
	    $foundCleavageStart = 1;
	}
	if (($i + 1) == $targetModelCleavageSeqEnd){  #found end, stop
	    last;
	}
    }

    #check if matches up with annotated cleavage sequence
    my $cleavageSequence = $seqInfo->{cleavageSequence};

    my $lengthWithGaps = $targetModelCleavageSeqEnd - $targetModelCleavageSeqStart + 1;
    my $modelCleavageSequence = substr($targetSequence, $targetModelCleavageSeqStart - 1, $lengthWithGaps);

    $modelCleavageSequence =~ s/\-//g;  #substitute gaps to get accurate cleavage sequence for comparison
    
    if ($modelCleavageSequence ne $cleavageSequence){
	
	my $errorString = "Did not get match in cleavage sequence in alignment file name $alignmentFileName: expected: $cleavageSequence found $modelCleavageSequence"; 
	$self->writeError($modbaseSeqId, $cleavageSeqId, 0, "mismatch_cleavage_sequence_in_alignment_file", "getTemplateLoopAlignment", $errorString, 1);
    }

    return ($targetModelCleavageSeqStart, $targetModelCleavageSeqEnd);
}
	



#gets the $seqInfo attribute name for the accession type passed in
sub getAccessionTypeAttributeName{

    my ($self, $accessionType) = @_;

    if ($accessionType ne "uniprot" && $accessionType ne "ensembl"){
	die "ERROR: getAccessionAttributeName must be passed argument of either uniprot or ensembl";
    }

    my $initialAccessionType = $self->getParam("initial_accession_type");  #check if we are being passed the name of the source db for this sequence

    if ($initialAccessionType eq $accessionType){
	return "secondaryId";   #primary identifier for this sequence from its db source, but secondary to the modbase sequence identifier
    }
    else {
	return "alternateAccession";  #tertiary identifier
    }
}


sub getTemplatePdbIds{

    my ($self, $modbaseSeqId, $pOneResidue, $fullAlignmentFileName, $run) = @_;
    
    my $runInfo = $self->getRunInfo();
    my $runStyle = $runInfo->{$run}->{style};
    
    my ($targetInfoLine, $targetSequence, $templateInfoLine, $templateSequence) = $self->parseAlignmentFile($fullAlignmentFileName, $run);

    #new-style modpipe runs have target as first protein in ali file; old style has template; process file accordingly
    #figure out which line is the template info line
    my $lineToProcess;
    
    my @cols = split('\:', $templateInfoLine);
    my $pdbCode = $cols[1];
    my $proteinType = $cols[0];  #either 'structure' or 'structureX' depending on run type
    
    unless ($pdbCode =~ /^\S\S\S\S$/){    #expect 4 letter pdb code
	my $errorString = "Did not get four letter pdb code (got $pdbCode) in first column of pir line in expected position in alignment file $fullAlignmentFileName run style $runStyle";
	$self->writeError($modbaseSeqId, $pOneResidue, 0, "unexpected_pdb_code_in_alignment", "getBestModels", $errorString, 1);
	$pdbCode = "template_pdb_code_error";
    }
    unless ($proteinType =~ /structure/){   
	my $errorString = "Did not get protein type of 'structure' (got $proteinType) in first column of pir format in expected position in alignment file $fullAlignmentFileName run style $runStyle";
	$pdbCode = "template_pdb_code_error";
	$self->writeError($modbaseSeqId, $pOneResidue, 0, "incorrect_template_position_in_alignment", "getBestModels", $errorString, 1);
    }

    return $pdbCode;
}


sub copyAlignmentFile{
 
    my ($self, $run, $modbaseSeqId, $alignmentId, $destinationDir) = @_;
        
    my $alignmentFileName = $alignmentId . ".ali";
    my $fullAlignmentFileName = $self->getAlignmentFileName($modbaseSeqId, $alignmentId, $run);
    
    if (-e $fullAlignmentFileName == 0){
	$self->writeLog("ERROR: did not find alignment file $fullAlignmentFileName for sequence $modbaseSeqId");
	return 0;
    }

    my $cpAlignmentCmd = "cp $fullAlignmentFileName $destinationDir";
    system($cpAlignmentCmd);

    my $outputFile = $destinationDir . "/" . $alignmentFileName;

    return $outputFile;

}

sub copyAndUnzipModelFile{

    my ($self, $run, $modbaseSeqId, $modelId, $destinationDir) = @_;

    # get model -- same as DSSP, consider refactoring
    my $modbaseModelDir = $self->getModelPath($run, $modbaseSeqId, $modelId);
    
    my $modelZipFile = $modbaseModelDir . "/" . $modelId . ".pdb.gz";
    
    if (-e "$modelZipFile" == 0){
	$self->writeLog("ERROR: did not find model for model id $modelId when searching $modelZipFile");
	return 0;
    }
    
    my $destinationFile = "$destinationDir/$modelId.pdb.gz";

    #make destination directory, copy model pdb, unzip
    my $cpModelCmd = "cp $modelZipFile $destinationFile";
    my $cpOutput = `$cpModelCmd 2>&1`;
    
    my $unzipCmd = "gunzip -f $destinationFile";
    my $unzipOutput = `$unzipCmd 2>&1`;
    
    my $outputFile = $destinationDir . "/$modelId" . ".pdb";
    return $outputFile;

}

#returns 0 if not found.  
sub copyAndUnzipPdbFile{

    my ($self, $pdbCode, $destinationDir) = @_;
    
    my $fullPdbFile = $self->getFullPdbFile($pdbCode);

    if (-e "$fullPdbFile" == 0){
	$self->writeLog("ERROR: did not find pdb file $pdbCode when searching $fullPdbFile");
	return 0;
    }
    
    my $destinationFile = $destinationDir . "/$pdbCode" . ".pdb.gz";

    my $cpPdbCmd = "cp $fullPdbFile $destinationFile";
    system($cpPdbCmd);

    my $unzipCmd = "gunzip -f $destinationFile";
    system($unzipCmd);

    my $outputFile = $destinationDir . "/" . $pdbCode . ".pdb";

    return $outputFile;
}


sub getFullPdbFile{

    my ($self, $pdbCode) = @_;

    #make dir using middle two letters of pdb file, eg /park2/database/pdb/divided/cf/2cf5.ent.gz

    my $pdbDir = $self->getParam("pdb_file_directory");
    $pdbCode =~ /\w(\w\w)\w/;
    my $middleTwoLetters = $1;

    my $fullDir = $pdbDir . "/" . $middleTwoLetters . "/pdb" . $pdbCode . ".ent.gz";

    return $fullDir;
}



sub countCleavageSiteLoopLength{
    my ($self, $cleavageSiteSSInfo, $cleavageSeqStartPosition, $cleavageSeqEndPosition) = @_;
    
    my $checkLoop;
    $checkLoop->{"S"} = 1;
    $checkLoop->{"T"} = 1;
    $checkLoop->{"L"} = 1;
    
    my $firstResidueIsLoop = $checkLoop->{$cleavageSiteSSInfo->{$cleavageSeqStartPosition}};
    my $lastResidueIsLoop = $checkLoop->{$cleavageSiteSSInfo->{$cleavageSeqEndPosition}};
    my $beforeFirstResLoopCount = 1;
    my $afterFirstResLoopCount = 0;
    my $beforeLastResLoopCount = 1;
    my $afterLastResLoopCount = 0;
    if ($firstResidueIsLoop){
	
	for (my $i = $cleavageSeqStartPosition; $i > 0 && $checkLoop->{$cleavageSiteSSInfo->{$i}}; $i--){
	    $beforeFirstResLoopCount++;
	}
       		
	for (my $i = $cleavageSeqStartPosition + 1; $i < (scalar (keys %$cleavageSiteSSInfo) - 1) && $checkLoop->{$cleavageSiteSSInfo->{$i}}; $i++){
	    $afterFirstResLoopCount++;
	}
	
	my $loopTotal = $beforeFirstResLoopCount + $afterFirstResLoopCount;
	return $loopTotal;
    }
    elsif ($lastResidueIsLoop){
	
	for (my $i = $cleavageSeqEndPosition; $i > 0 && $checkLoop->{$cleavageSiteSSInfo->{$i}}; $i--){
	    $beforeLastResLoopCount++;
	}

	for (my $i = $cleavageSeqEndPosition + 1; $i < (scalar (keys %$cleavageSiteSSInfo) - 1) && $checkLoop->{$cleavageSiteSSInfo->{$i}}; $i++){
	    $afterLastResLoopCount++;
	}
	my $loopTotal = $afterLastResLoopCount + $beforeLastResLoopCount;
	return $loopTotal;
    }
    else {
	return 0;
    }
}

sub getAlignmentFileName{

    my ($self,  $modbaseSeqId, $alignmentId, $runName) = @_;

    my $runInfo = $self->getRunInfo();
    my $style = $runInfo->{$runName}->{style};
    my $path = $runInfo->{$runName}->{path};
       
    my $alignmentFileName;

    #retrieve full file path of alignment file; this will vary depending on which run style was used

    if ($style eq "old"){
	$alignmentId =~ /^(\S\S).*/;
	my $twoLetterCode = $1;

	$alignmentFileName = "$path" . "alignments/$twoLetterCode/$alignmentId/$alignmentId" . ".ali";
    }
    else {
	$modbaseSeqId =~ /^(\S\S\S).*/;
	my $threeLetterCode = $1;
	
	$alignmentFileName = "$path" . "$threeLetterCode/$modbaseSeqId/alignments/$alignmentId" . ".ali";
    }
    return $alignmentFileName;
}


sub getModelPath{

    my ($self, $run, $modbaseSeqId, $modelId) = @_;

    my $runInfo = $self->getRunInfo();

    #$parentDir: very top level directory that contains all two or three letter directories for each entry

    my $parentDir = $runInfo->{$run}->{path};
    my $style = $runInfo->{$run}->{style};

    my $fullModelPath = $parentDir;

    if ($style eq "old"){       #organized by model IDs; eg /park4/home/modbase/snp-human2/data/models/0a/0a80c1261f614500bef5270cd1441ea6
	$modelId =~ /^(\S\S)\S+/;
	$fullModelPath .= "/models/" .  $1 . "/" . $modelId;
    }
    elsif ($style eq "new"){    #organized by sequence IDs; eg /park1/modbase/projects/rachel/human_4-2007/data/275/27511e03b7a619d076a5341baa2156c3MGAFTNAF/models
	$modbaseSeqId =~ /^(\S\S\S)\S+/;
	$fullModelPath .= $1 . "/" . $modbaseSeqId . "/models";
     }
    else {
	die "style for run $run needs to be \'old\' or \'new\'\n";
    }

    return $fullModelPath;

}




#taken from Rose et al, Science, 1985, which determined these values using atomic radii calculated in Lee & Richards, 1971
sub getResidueSolventAcc{

    my ($self) = @_;

    my $residues;

    $residues->{"A"} = 118.1;
    $residues->{"C"} = 146.1;
    $residues->{"D"} = 158.7;
    $residues->{"E"} = 186.2;

    $residues->{"F"} = 222.8;
    $residues->{"G"} = 88.1;
    $residues->{"H"} = 202.5;
    $residues->{"I"} = 181.0;

    $residues->{"K"} = 225.8;
    $residues->{"L"} = 193.1;
    $residues->{"M"} = 203.4;
    $residues->{"N"} = 165.5;

    $residues->{"P"} = 146.8;
    $residues->{"Q"} = 193.2;
    $residues->{"R"} = 256.0;
    $residues->{"S"} = 129.8;

    $residues->{"T"} = 152.5;
    $residues->{"V"} = 164.5;
    $residues->{"W"} = 266.3;
    $residues->{"Y"} = 236.8;

    return $residues;

}

sub getSolventExposureFraction{
    my ($self, $accessibility, $residueName, $residueSolventAcc) = @_;

    $accessibility *= 1.0;
		
    my $totalSa = $residueSolventAcc->{$residueName};
    my $percentSa = $accessibility / $totalSa;
       
    my $accCall;
    if ($percentSa > 0.33){
	$accCall .= "A";
    }
    else {
	$accCall .= "N";
    }

    return ($percentSa, $accCall);
}

sub getMappedStructureType{

    my ($self, $structureInputType) = @_;

    if ($structureInputType =~ /^\s+$/){
	return ("L", 1);
    }

    if ($structureInputType eq "H" || $structureInputType eq "G" || $structureInputType eq "I"){
	return ("A", 2);
    }
    if ($structureInputType eq "B" || $structureInputType eq "E"){
	return ("B", 3);
    }
    if ($structureInputType eq "S" || $structureInputType eq "T" || $structureInputType eq "L"){
	return ("L", 1);
    }
}

sub getModelCleavageRange{

    my ($self, $seqInfo) = @_;

    my $offsets;

    my $offset = $self->getModelOffset($seqInfo);
    
    my $cleavageSeqStartPosition = $seqInfo->{cleavageSeqStartPosition};
    my $cleavageSeqEndPosition = $seqInfo->{cleavageSeqEndPosition};
    
    $cleavageSeqStartPosition -= $offset;
    $cleavageSeqEndPosition -= $offset;

    return ($cleavageSeqStartPosition, $cleavageSeqEndPosition);
}

sub getModelOffset{
 
    my ($self, $seqInfo) = @_;

    my $run = $seqInfo->{run};
    my $runInfo = $self->getRunInfo();
    if (($run ne "human") && ($run ne "human_4-2007") && ($run ne "snp-human2")  && ($run ne "snp-human3")  && ($run ne "snp-human4") && ($run ne "trembl2004") && ($run ne "human_2008" )){
	die "run for this sequence not of expected type: $run\n";
    }
    
    my $hasOffset = $runInfo->{$run}->{offset};
    
    my $offset;

    if ($hasOffset){
	$offset = $seqInfo->{modelTargetStart} - 1;
    }
    else {
	$offset = 0;
    }
    return $offset;
}

sub writeAllModelsLine{

    my ($self, $secondaryId, $modbaseSeqId, $modelId, $run, $modelTargetStart, $modelTargetEnd, $cleavageSeqStartPosition, 
	$cleavageSeqEndPosition, $modelScore, $seqIdentity, $roundedCoverage, $allModelsFh) = @_;

    print $allModelsFh "$secondaryId";
    
    if ($modelTargetStart <= $cleavageSeqStartPosition && $modelTargetEnd >= $cleavageSeqEndPosition){
	print $allModelsFh "\tyes";
    }
    else{
	print $allModelsFh "\tno";
    }
    if (($cleavageSeqStartPosition <= $modelTargetStart && $cleavageSeqEndPosition >= $modelTargetStart) 
	|| ($cleavageSeqStartPosition <= $modelTargetEnd && $cleavageSeqEndPosition >= $modelTargetEnd)){
	
	print $allModelsFh "\tyes";
    }
    else {
	print $allModelsFh "\tno";
    }

    print $allModelsFh "\t$modelTargetStart\t$modelTargetEnd\t$cleavageSeqStartPosition\t$cleavageSeqEndPosition\t$modelScore\t$seqIdentity\t$roundedCoverage\t$run";

    my $url = "http://salilab.org/modbase/search?modelID=" . $modelId . "&displaymode=moddetail";

    print $allModelsFh "\t$modbaseSeqId\t$modelId\t$url";

    print $allModelsFh "\n";

}

sub checkResidue{

    my ($self, $residueOneLetter, $positionInCleavageSeq, $cleavageSequence, $seqId) = @_;

    my @residues = split('', $cleavageSequence);

    my $codeInCleavageSeq = $residues[$positionInCleavageSeq - 1];
    if ($residueOneLetter ne $codeInCleavageSeq){
	$self->writeLog("ERROR: cleavage seq error:  cleavage seq has residue $codeInCleavageSeq at position $positionInCleavageSeq but in dssp file the residue is $residueOneLetter for sequence $seqId");
    }
}



#######################
#Pipeline Methods
#######################


sub logDescription{

    my ($self) = @_;
    my $description = $self->getParam("run_description");
    $self->writeLog("Pipeline run description: $description");

}

sub writeAllErrors{

    my ($self) = @_;
    my $errors = $self->{Errors};
    
    $self->writeLog("Errors encountered in the pipeline:\n");
    foreach my $errorCode (keys %$errors){
	my $sequenceCount = 0;
	my $pOnePositionCount = 0;
	my $modbaseSeqIds = $errors->{$errorCode};
	my $errorDescription = $self->{ErrorCodes}->{$errorCode};
	
	foreach my $modbaseSeqId (keys %$modbaseSeqIds){
	    print STDERR $errorCode . "\t" . $modbaseSeqId . "\n";
	    $sequenceCount++;
	    my $pOnePositions = $modbaseSeqIds->{$modbaseSeqId};
	    foreach my $pOnePosition (keys %$pOnePositions){
		$pOnePositionCount++;
	    }
	}
	my $outputString = "\n\t$errorDescription\n\t$sequenceCount modbase sequences containing $pOnePositionCount unique cleavage sequences were affected.\n";
	$self->writeLog($outputString);
    }

}

sub createColumnInfo{
    
    my ($self) = @_;

    my $columnInfo;
    
    $self->addColumn("uniprotAccession", "Uniprot Accession", "normal");
    $self->addColumn("alternateAccession", "Alternate ID", "normal");
    $self->addColumn("spliceAccession", "Sequence Splice Form", "normal");
    $self->addColumn("totalModelCount", "Total Models For Sequence", "normal");
    $self->addColumn("sequenceModelCount", "Models Containing Cleavage Sequence", "normal");
    $self->addColumn("run", "Dataset", "normal");
    $self->addColumn("modelTargetStart", "Target Start", "normal");
    $self->addColumn("modelTargetEnd", "Target End", "normal");
    $self->addColumn("cleavageSeqStartPosition", "Cleavage Seq Start", "normal");
    $self->addColumn("pOnePosition", "P1 Position", "normal");
    $self->addColumn("cleavageSeqEndPosition", "Cleavage Seq End", "normal");
    $self->addColumn("cleavageSequence", "Cleavage Sequence", "normal");
    $self->addColumn("hmmScore", "HMM Score", "applyHmm");
    $self->addColumn("hmmEValue", "HMM E-Value", "applyHmm");
    $self->addColumn("modelScore", "Model Score", "normal");
    $self->addColumn("zDope", "Dope Score", "normal");
    $self->addColumn("nativeOverlap", "TSVMod Native Overlap", "normal");
    $self->addColumn("tsvmodMethod", "TSVMod Method", "normal");
    $self->addColumn("seqIdentity", "Template Sequence Identity", "normal");
    $self->addColumn("coverage", "Model Coverage", "normal");
    $self->addColumn("loopLength", "Loop Length", "normal");
    $self->addColumn("sharedProteaseInfo", "Shares Site With Other Protease", "normal");
    $self->addColumn("description", "Name", "normal");
    $self->addColumn("templatePdbIds", "Template PDB ID", "normal");
    $self->addColumn("similarityString", "Cleavage Sequence Similarity To Template", "normal");
    $self->addColumn("templateCleavageSequence", "Corresponding Sequence in Template", "normal");
    $self->addColumn("structureTypes", "Cleavage Sequence Structure Type", "runDssp");
    $self->addColumn("accessibilityTypes", "Cleavage Sequence Accessibility Type", "runDssp");
    $self->addColumn("structureValues", "Cleavage Sequence Structure Values", "runDssp");
    $self->addColumn("accessibilityFractions", "Cleavage Sequence Accessibility Fractions", "runDssp");
    

    my $cellLinesUsed = $self->getParam("cell_lines_to_use");
    my @cellLineColumnNames = split(',', $cellLinesUsed);
    foreach my $cellLine (@cellLineColumnNames){
	$self->addColumn($cellLine, $cellLine, "addLysateExpression");
    }

    $self->addColumn("disopredString", "Disorder Prediction", "processDisopredResults");
    $self->addColumn("disopredFirstScores", "Disopred Scores", "processDisopredResults");
    $self->addColumn("profAccString", "Prof Three-State Accessibility", "processProfResults");
    $self->addColumn("relativeAccScore", "Prof Scores", "processProfResults");
    $self->addColumn("profReliability", "Prof Reliability", "processProfResults");
    $self->addColumn("psipredString", "PSIPRED results", "processPsipredResults");
    $self->addColumn("psipredFirstScores", "PSIPRED Scores", "processPsipredResults");
    $self->addColumn("availableAntibodyName", "Antibody Name", "addAntibodyAvailability");
    $self->addColumn("availableAntibodyProductNumber", "Antibody ProductNumber", "addAntibodyAvailability");
    $self->addColumn("domainBoundaries", "Domain Boundaries","processDomainAnnotation");
    $self->addColumn("domainBoundaryValue", "Boundary Cleavage Value", "processDomainAnnotation");
    $self->addColumn("goIdString", "GO IDs", "processGoAnnotation");
    $self->addColumn("goDescriptionString", "GO Functions", "processGoAnnotation");
    
    my $flagNames = $self->{FlagNames};
    my $outputFlags = $self->{OutputFlags};

    foreach my $flagNumber (sort keys %$flagNames){
	my $flagName = $flagNames->{$flagNumber};
	if ($outputFlags->{$flagName} eq "yes"){
	    $self->addColumn($flagName, $flagName, "flag");
	}
    }

    $self->addColumn("fullAlignmentFilePath", "Alignment File Path", "normal");
    $self->addColumn("sequenceId", "Sequence ID", "normal");
    $self->addColumn("modelId", "Model ID", "normal");
    $self->addColumn("url", "URL", "normal");

}

sub addColumn{

    my ($self, $internalId, $display, $type) = @_;

    if (lc($display) eq "status"){
	die "cannot add the column 'status' to output; it is a reserved word for benchmarking\n";   #until we make classes for all of these attributes this is the best I can do
    }

    $self->{Columns}->{$internalId}->{display} = $display;
    $self->{Columns}->{$internalId}->{type} = $type;

    my $currentCounter = $self->{ColumnCounter};
    $self->{Columns}->{$internalId}->{displayOrder} = $currentCounter;
    $self->{ColumnCounter}++;
}

sub addOutputValue{
    my ($self, $outputInfo, $value, $internalName) = @_;
    
    my $columns = $self->{Columns};
    my $columnInfo = $columns->{$internalName};
    unless ($columnInfo){
	my $keyString = join(", ", keys %$columns);
	print STDERR "ERROR:  trying to add value to column info with internal id $internalName which is not a defined internal id.  List of these IDs:\n$keyString\n";
	exit(1);
    }
    $outputInfo->{$internalName} = $value;

    return $outputInfo;
}

sub makeColumnHeaderString{

    my ($self) = @_;

    my $columnHeaderString = "";

    my $columns = $self->{Columns};
    foreach my $internalId (sort ({$columns->{$a}->{displayOrder} <=> $columns->{$b}->{displayOrder}} keys %$columns)){
	my $type = $columns->{$internalId}->{type};
	if ($type eq "normal" || $type eq "flag"){
	    my $displayName = $columns->{$internalId}->{display};
	    $columnHeaderString .= $displayName . "\t";
	}
	else {
	    if ($self->runMethod($type, 1)){
		my $displayName = $columns->{$internalId}->{display};
		$columnHeaderString .= $displayName . "\t";
	    }
	}
    }
    return $columnHeaderString;
}

sub makeOutputLine{
    my ($self, $outputInfo) = @_;
    my $columns = $self->{Columns};
    my $outputLine = "";
    foreach my $internalId (sort ({$columns->{$a}->{displayOrder} <=> $columns->{$b}->{displayOrder}} keys %$columns)){
	my $type = $columns->{$internalId}->{type};
	if ($type eq "normal" || $type eq "flag"){
	    my $nextOutputValue = $outputInfo->{$internalId};
	    $outputLine .= $nextOutputValue . "\t";
	}
	else {
	    if ($self->runMethod($type, 1)){
		my $nextOutputValue = $outputInfo->{$internalId};
		$outputLine .= $nextOutputValue . "\t";
	    }
	}
    }
    return $outputLine;
}


sub initializePipelineDirectories{
    my ($self) = @_;

    my $runName = $self->getParam("run_name");
    my $pipelineDir = $self->getParam("pipeline_directory");
    
    my $pipelineRun = "$pipelineDir/runs/$runName/";
    my $cmd = "mkdir -p $pipelineRun/pipelineResults";
    system($cmd);
}


sub getDbh {
    my ($self) = @_;
    return $self->{DBH};
}

sub loadDbh{

    my ($self) = @_;

    my $dbString = "DBI:mysql:database=modbase:hostname=modbase";
    my $username = "modbase";
    my $password = "modbasesecret";
    
    my $dbh = DBI->connect( $dbString, $username, $password, {RaiseError => 1});
    $self->{DBH} = $dbh;
}


sub loadSynonymDbh{   #needs updating

    my ($self) = @_;
    my $dbString = "DBI:mysql:database=modbase_synonyms:hostname=modbase";
    my $username = "modbase";
    my $password = "modbasesecret";
    
    my $dbh = DBI->connect( $dbString, $username, $password, {RaiseError => 1});
    $self->{Synonym_DBH} = $dbh;
}

sub getSynonymDbh{
    my ($self) = @_;
    return $self->{Synonym_DBH};

}
    
sub loadUniprotIdAccessionMap{
    my ($self) = @_;
    my $uniprotIdAccessionMapFileName = $self->getParam("uniprot_id_accession_map_file_name");

    my $fh = FileHandle->new("<" . $uniprotIdAccessionMapFileName) || die "could not open uniprot id map file name $uniprotIdAccessionMapFileName";

    my $uniprotIdToAccessionMap;
    my $uniprotAccessionToIdMap;

    while (<$fh>){
	chomp;
	my $line = $_;
	my @cols = split(' ', $line);
	my $id = shift(@cols);
	foreach my $acc (@cols){

	    $uniprotIdToAccessionMap->{$id}->{$acc} = 1;
	    $uniprotAccessionToIdMap->{$acc} = $id;
	}
    }
    $self->{UniprotIdToAccessionMap} = $uniprotIdToAccessionMap;
    $self->{UniprotAccessionToIdMap} = $uniprotAccessionToIdMap;
}



sub readParameterFile{

    my ($self, $parameterFile) = @_;

    my $parameterFh = FileHandle->new("<" . $parameterFile) || die "could not open $parameterFile\n";

    while (<$parameterFh>){
	chomp;
	my $line = $_;

	my ($paramName, $paramValue) = split('\t', $line);
	$self->{Parameters}->{$paramName} = $paramValue;
    }
    $self->{ParameterFileName} = $parameterFile;

}

sub getParam{

    my ($self, $paramName) = @_;
    my $paramValue = $self->{Parameters}->{$paramName};
    if (!($paramValue)){
	$self->writeLog("Error: given parameter ($paramName) is not valid.");
	$self->writeLog("Valid parameters:");
	my $logString = "";
	foreach my $parameter (keys %{$self->{Parameters}}){
	    $logString .= "--" . $parameter . "\n";
	}
	$self->writeLog($logString . "\n\n");

	exit(1);
    }
    return $paramValue;
}

sub initialize{
    my ($self) = @_;

    $self->{ColumnCounter} = 1;

    $self->loadErrorCodes();
    $self->loadDbh();
    $self->loadSynonymDbh();
    $self->loadRunInfo();
    $self->loadLog();
    
    $self->loadUniprotIdAccessionMap();

    $self->logDescription();
    $self->loadSimilarityGroups();

    $self->loadMethodDependencies();

    $self->validateParameters();

    $self->initializePipelineDirectories();
}


sub validateParameters{
    my ($self) = @_;
    my $bestModelCriteria = $self->getParam("best_model_criteria");
    unless ($bestModelCriteria eq "modelScore" || $bestModelCriteria eq "coverage" || $bestModelCriteria eq "nativeOverlap"){
	print STDERR "ERROR: Please set --bestModelCriteria to be one of \'modelScore\', \'coverage\', \'nativeOverlap\' (current value: $bestModelCriteria)\n";
	exit(1);
    }

}



sub loadMethodDependencies{
    my ($self) = @_;

    $self->{MethodDependencies}->{"runDssp"}->{"getBestModels"} = 1; 
    $self->{MethodDependencies}->{"parseDsspResults"}->{"getBestModels"} = 1; 
    $self->{MethodDependencies}->{"getTemplateLoopAlignment"}->{"getBestModels"} = 1; 

    $self->{MethodDependencies}->{"parseDsspResults"}->{"runDssp"} = 1; 

    $self->{MethodDependencies}->{"getBestModels"}->{"getSequenceLengths"} = 1;
    
#    $self->{MethodDependencies}->{"addLysateExpression"}->{"mapAccessions"} = 1;   only include if we are using secondary accessions in lysate info (currently only primary)
    $self->{MethodDependencies}->{"addAntibodyAvailability"}->{"mapSecondaryAccessions"} = 1;   

    #perhaps processNameAnnotation
    
}

sub loadSimilarityGroups{
    my ($self) = @_;

    my $unchargedGroup = $self->makeSimilarityGroup("V", "I", "A", "L", "P", "W", "G", "F", "C", "M");
    my $basicGroup = $self->makeSimilarityGroup("H", "R", "K");
    my $acidicGroup = $self->makeSimilarityGroup("D", "E");
    my $unchargedPolarGroup = $self->makeSimilarityGroup("S", "T", "Y", "Q", "N");
}

sub makeSimilarityGroup{
    my ($self, @residues) = @_;   #take dynamic list of residues as input and set each as a key to the group and all others as values

    my $similarityGroup;
    foreach my $residue(@residues){
	foreach my $nextRes (@residues){
	    if ($residue ne $nextRes){
		$self->{SimilarityGroups}->{$residue}->{$nextRes} = 1;
	    }
	}
    }
    return $similarityGroup;

}


sub loadErrorCodes{

    my ($self) = @_;
    $self->{ErrorCodes}->{"no_dssp_structure_info"} = "Sequences for which there were models but DSSP secondary structure output file could not be read at the cleavage sequence position.";
    $self->{ErrorCodes}->{"no_model_in_expected_directory"} = "Sequences for which there was a best model but it was not found in expected source modbase directory.";

    $self->{ErrorCodes}->{"no_disopred_result_file"} = "Sequences for which no Disopred results file was found.";
    $self->{ErrorCodes}->{"disopred_sequence_mismatch"} = "Sequences for which the residues at the cleavage sequence positions in the Disopred results file did not match up with the annotated cleavage sequence.";

    $self->{ErrorCodes}->{"no_prof_result_file"} = "Sequences for which no Prof results file was found.";
    $self->{ErrorCodes}->{"prof_sequence_mismatch"} = "Sequences for which the residues at the cleavage sequence positions in the Prof results file did not match up with the annotated cleavage sequence.";

    $self->{ErrorCodes}->{"no_psipred_result_file"} = "Sequences for which no Psipred results file was found.";
    $self->{ErrorCodes}->{"psipred_sequence_mismatch"} = "Sequences for which the residues at the cleavage sequence positions in the Psipred results file did not match up with the annotated cleavage sequence.";
    $self->{ErrorCodes}->{"no_psipred_cleavage_sequence"} = "Sequences for which there was a PSIPRED results file but the start position of the cleavage sequence was not found in the file.";

    $self->{ErrorCodes}->{"unexpected_pdb_code_in_alignment"} = "Alignment files that did not have a four letter pdb code in the expected column in the pir line for the template.";
    $self->{ErrorCodes}->{"incorrect_template_position_in_alignment"} = "Alignment files that appear to have the template in the wrong position (first or second relative to the target) as expected according to the modpipe style";

    $self->{ErrorCodes}->{"mismatch_cleavage_sequence_in_alignment_file"} = "Alignment files that did not have the annotated cleavage sequence at the expected position for the target sequence.";

    $self->{ErrorCodes}->{"unexpected_lysate_call"} = "Entries in lysate file that did not have 'A' or 'P' in expected column";

}

sub loadLog{
    my ($self) = @_;

    my ($sec,$min,$hour,$mday,$mon,$year,$wday, $yday,$isdst)=localtime(time);

    $year += 1900;
    $mon+=1;
    if ($mon =~ /^\d$/){
	$mon = "0" . $mon;
    }

    if ($mday =~ /^\d$/){
	$mday = "0" . $mday;
    }
    my $timeStamp = $year . "_" . $mon . "_" . $mday;
    my $run = $self->getParam("run_name");
    my $pipelineDir = $self->getParam("pipeline_directory");
    my $logFileName = "$pipelineDir/bin/pipelineLog-" . $run . "-" . $timeStamp;
    my $logFh = FileHandle->new(">" . $logFileName) || die "could not open $logFileName for writing\n";
    $self->{LogFileName} = $logFileName;
    $self->{Log} = $logFh;
}

sub writeLog {

    my ($self, $message) = @_;
    my $logFh = $self->{Log};
    my ($sec,$min,$hour,$mday,$mon,$year,$wday, $yday,$isdst)=localtime(time);

    my $dateLine = sprintf ("%4d-%02d-%02d %02d:%02d:%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec);

    print $logFh "$dateLine:\t$message\n";
}
    


sub isError{

    my ($self, $modbaseSeqId, $cleavageSeqId, $errorCode, $modelId) = @_;
    
    my $errorDescription = $self->{ErrorCodes}->{$errorCode};

    #check to see if this combination of $modbaseSeqId and $cleavageSeqId have been reported as errors with this $errorCode
    #uses $modelId if present in the error structure too

    #check valid error code
    unless ($errorDescription){
	
	$self->writeLog("Bailing out of pipeline due to code error");

	$self->writeAllErrors();
	$self->writeLog("Code Error:  attempted to run isError() with $errorCode which is not a valid error code");
	
	exit(1);
    }
    
    my $isError = 0;
    #slightly complicated way of going through {Errors} but if we do it all at once then it populates $modbaseSeqId as key to {Errors}
    my $testModbaseSeqId =  $self->{Errors}->{$errorCode}->{$modbaseSeqId};
    if ($testModbaseSeqId){   
	my $testCleavageSeqId =  $self->{Errors}->{$errorCode}->{$modbaseSeqId}->{$cleavageSeqId};
	if ($testCleavageSeqId){
	    if ($modelId){  #if $modelId is part of the error, check to see if it is present in the structure
		my $testModel = $self->{Errors}->{$errorCode}->{$modbaseSeqId}->{$cleavageSeqId}->{modelId};
		if ($testModel){
		    $isError = 1;
		}  #else leave $isError as 0
	    }
	    else {  #no model id, automatically is an error
		$isError = 1;
	    }
	}
    }
    return $isError;
}



sub writeError{

    my ($self, $modbaseSeqId, $cleavageSeqId, $modelId, $errorCode, $methodName, $errorMessage, $writeLog) = @_;

    my $errorDescription = $self->{ErrorCodes}->{$errorCode};
    unless ($errorDescription){
	
	$self->writeLog("Bailing out of pipeline due to code error");

	$self->writeAllErrors();
	$self->writeLog("Code Error:  attempted to log error code $errorCode which is not a valid error code");
	
	exit(1);
    }
	

    $self->{Errors}->{$errorCode}->{$modbaseSeqId}->{$cleavageSeqId}->{modelId} = $modelId;
    $self->{Errors}->{$errorCode}->{$modbaseSeqId}->{$cleavageSeqId}->{errorMessage} = $errorMessage;
    $self->{Errors}->{$errorCode}->{$modbaseSeqId}->{$cleavageSeqId}->{methodName} = $methodName;

    if ($writeLog){
	$self->writeLog("ERROR:  $methodName modbase seq id: $modbaseSeqId cleavage sequence: $cleavageSeqId model id: $modelId:\n\t$errorMessage\n");
    }

}

sub loadRunInfo{

    my ($self) = @_;

    my $runInfo;
    $runInfo->{"human"}->{path} = "/park1/modbase/projects/genomes/human/data/";
    $runInfo->{"human"}->{offset} = 1;
    $runInfo->{"human"}->{style} = "new";
  
    $runInfo->{"human_4-2007"}->{path} = "/park1/modbase/projects/rachel/human_4-2007/data/";
    $runInfo->{"human_4-2007"}->{offset} = 0;
    $runInfo->{"human_4-2007"}->{style} = "new";    

    $runInfo->{"human_2008"}->{path} = "/park2/modbase/projects/genomes/human_2008/data/";
    $runInfo->{"human_2008"}->{offset} = 0;
    $runInfo->{"human_2008"}->{style} = "new";    

    $runInfo->{"snp-human2"}->{path} = "/park2/modbase/snp-human2/data/";
    $runInfo->{"snp-human2"}->{offset} = 0;
    $runInfo->{"snp-human2"}->{style} = "old";

    $runInfo->{"snp-human3"}->{path} = "/park2/rachelk/alto3/ModPipe+/snp-human3/data/";
    $runInfo->{"snp-human3"}->{offset} = 0;
    $runInfo->{"snp-human3"}->{style} = "old";

    $runInfo->{"snp-human4"}->{path} = "/park2/rachelk/netapp/rachelk/ModPipe+/snp-human4/data/";
    $runInfo->{"snp-human4"}->{offset} = 0;
    $runInfo->{"snp-human4"}->{style} = "old";

    $runInfo->{"trembl2004"}->{path} = "/park2/modbase/TrEMBL2004/data/";
    $runInfo->{"trembl2004"}->{offset} = 0;
    $runInfo->{"trembl2004"}->{style} = "old";

#    $runInfo->{"ucla-smsl"}->{path} = "";
#    $runInfo->{"ucla-smsl"}->{offset} = 0;

#    $runInfo->{"ucla-parotid"}->{path} = "";
#    $runInfo->{"ucla-parotid"}->{offset} = 0;

    $self->{RunInfo} = $runInfo;
}

sub runMethod{

    my ($self, $methodName, $skipOutput) = @_;
    
    my $runMethodParamValue = $self->getParam($methodName);

    if ($runMethodParamValue eq "yes"){
	
	if ($self->fulfillsMethodDependencies($methodName) == 1){
	    
	    $self->writeLog("Running $methodName") unless $skipOutput;
	    return 1;
	}
	else {
	    $self->writeLog("Exiting.  Pipeline step $methodName was run without having other methods run which it depended on.  Full list of method dependencies:");
	    $self->writeMethodDependencies();
	    exit(1);
	}
		
    }
    elsif ($runMethodParamValue eq "no"){
	$self->writeLog("Skipping $methodName") unless $skipOutput;
	return 0;
    }
    else {
	$self->writeLog("Please set parameter value for running method '$methodName' to either 'yes' or 'no' (case sensitive)");
	exit(1);
    }
}

sub fulfillsMethodDependencies{

    my ($self, $methodName) = @_;
     my $dependencies = $self->{MethodDependencies}->{$methodName};
    foreach my $dependency (keys %$dependencies){

	my $dependencyIsSet = $self->getParam($dependency);
	if ($dependencyIsSet eq "no"){
	    return 0;
	}
	
    }
    return 1;
}

sub writeMethodDependencies{

    my ($self) = @_;
    my $allDependencies = $self->{MethodDependencies};
    foreach my $method (keys %$allDependencies){
	my $dependencies = $allDependencies->{$method};
	my $methodString = "$method: ";
	foreach my $dependency (keys %$dependencies){
	    $methodString .= "$dependency, ";
	}
	$self->writeLog($methodString);
    }

}


sub getRunInfo{
    my ($self) = @_;
    return $self->{RunInfo};
}

return 1;




#HMM:
# Why are HMM lengths only 7 or 8 even when trained on larger sequences?

#ISSUES
#  Probably are a ton of other things in the Word Document

#STRUCTURAL PARAMETERS
#  Write pipeline protrusion index
#  Write pipeline OOI number

#DSSP
# Still a couple places where there is error message about cleavage sequence, try to address this

#PROTEOME
# figure out why some modbase sequences have lengths of 0 (returned from getSequenceLength) -- I thought I had taken all of those out when I made the fasta file for HMM input.
# Check HMM score -- used -5.06

#OTHER QUESTIONS
# For known substrates, for each protein, how does the positive cleavage sequence compare to the negatives, in both sequence and structure (do this on a protein by protein basis)
# Consider running on different size inputs (probably will need to have different HMM cutoff score) and see what that does to false positive rate overall


#DOMAINS
#Some day, get it working

#GENE ONTOLOGY
# Test GO Annotation method

#CASPASE
# Rerun caspase using new way to get IDs (starting with NR) -- maybe after human proteome is done?
# See if Disopred predicts alpha helices as being disordered

# IDEAS (probably better in Word doc too)
# Look at other solved structures that are GrB substrates, reconcile with AIF1 prediction (maybe incorporate new features?)
# Go through Word document -- most stuff should be on here, but if not see what is useful.

# ERROR HANDLING
# No lengths in getSequenceLengths
# No name in getNameAnnotation -- then see how many input sequences have a problem and consider alternate processing to handle them
# Look for others

#CODE
# Logging sequences processed (every %1000) will have to do in multiple methods that it might be required for
# Log die messages.  Make sure dies are only used in the case of severe code error.  Have method that will writeAllErrors before it dies.
# Validations steps:  Output flag check (output flag value must be yes or no); if method is expecting a specific flag then something that validates it is set, 
# Validate certain parameters to make sure they are terms in CV when pipeline starts up.  Current list: (bestModelCriteria) (initial_accession_type) (method getAccessionAttributeName) (cellLinesToUse)
# Assertions to avoid this from becoming unmanageable (starting to get really huge despite best organization efforts)
# Subversion
# Ability to restart pipeline if something dies (will probably have to dump $substrateInfo after each method run)
# clean up checkLoop() (needs better documentation and probably assertions)
# Keep up with documentation
# Have full alignment file path be set as its own method (or in get best model) so other methods don't have to keep getting it (and can also set in $seqInfo and print out in spreadsheet)
# added alignment file path to output value as default -- think that won't break anything but keep an eye on it
# See why we are outputting some error codes but not all in writeAllErrors, even if there are 0 sequences that the error applied to (unintentional populating of that error code?)

# MODPIPE ISSUES:
#alignment files for old vs new are in different orders
#rachels models have been moved -- is this reflected in DB?
#different pdb residue numbering
#different directory orders.
#random tables, unclear which is old and which is new (might be documented)

#NOTES AND REMINDERS:
#-----
# Decided not to query aa_sequences_old table when generating initial fasta file from which HMM input will be generated and used in the run for the human proteome.  33,000 sequences from the merged set of the two human runs is enough and the human proteome is being re-run in modpipe
# Note --accidentally reran Pipeline using GrB Proteome Parameters file, so if look at that for some reference and get unexpected result, that is why (11/12/08).
# "Mystery" human proteome sequences - ie others that aren't currently appearing (although consider how much effort to spend on all of this if modpipe is being re-run on proteome)
# See how many modbase sequence IDs we are missing from merged human runs, and of those how many don't have uniprot IDs or accessions, after doing all this.  Most recent count said that ~7000 were missing (but not sure if that was Uniprot IDs or Modbase Sequence IDs)   -- DONE -- about 7000 do not have Uniprot IDs (fixed after not restricting Uniprot ID being in uniprot_taxonomy) and ~10000 additionally don't have any sequence in aasequences (they are in aa_sequence_old).  The ones not in uniprot_taxonomy I just took from NR.  There were about 1,400 sequences that didn't have Uniprot Accessions in NR either -- genbank or something, will have to account for that in methods that depend on having an accession
#Numbers:
#~44,000 merged set of human and human_2004
#33,000 sequences that are in aasequences (as opposed to aasequences_old)
#26,000 sequences that have uniprot entry in uniprot_accessions
#18795 sequences have entry in uniprot_accessions where is_current = 1;

#BEFORE NEXT PIPELINE RUN
# All error handling
# GO Annotation?  Might be helpful for Dan
# ProfPhd
# Protrusion index?
# Residue Packing?
# Whether sequence matches exactly a different one that is cleaved


#DAN GROUP MEETING QUESTIONS
#Overlap between COFRADIC and Grbah (esp with Gene Portal)
#In proteome predictions look specifically at whether known substrates stand out
#Overlap between his proteomic method and known results, again incl Gene Portal. Since this comes up so much, it would be good to write a good method for it that takes into account different accessions
#Look at structural properties of cleavage sequences that are buried and also candidate ones with close or exact matches that aren't cleaved
